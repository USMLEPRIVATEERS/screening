<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ward Academy - Systematic Review Screening Tool</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        .highlight-include {
            background-color: #86efac;
            padding: 2px 4px;
            border-radius: 2px;
        }
        .highlight-exclude {
            background-color: #fca5a5;
            padding: 2px 4px;
            border-radius: 2px;
        }
        .highlight-methods {
            background-color: #fde047;
            padding: 2px 4px;
            border-radius: 2px;
        }
        .study-card {
            transition: all 0.3s ease;
        }
        .study-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.6);
        }
        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 30px;
            border: 1px solid #888;
            width: 90%;
            max-width: 1200px;
            border-radius: 8px;
            max-height: 85vh;
            overflow-y: auto;
        }

        /* Responsive modal styles */
        @media (max-width: 1024px) {
            .modal-content {
                width: 95%;
                padding: 20px;
                margin: 3% auto;
            }
        }

        @media (max-width: 768px) {
            .modal-content {
                width: 98%;
                padding: 15px;
                margin: 2% auto;
                max-height: 90vh;
            }

            .modal-content h2 {
                font-size: 1.25rem;
            }

            .modal-content table {
                font-size: 12px;
            }

            .modal-content table td,
            .modal-content table th {
                padding: 6px;
            }
        }

        @media (max-width: 640px) {
            .modal-content {
                width: 100%;
                height: 100%;
                max-height: 100vh;
                margin: 0;
                border-radius: 0;
                padding: 10px;
            }

            .modal-content table {
                font-size: 10px;
            }

            .modal-content table td,
            .modal-content table th {
                padding: 4px;
            }
        }
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        .close:hover,
        .close:focus {
            color: #000;
        }
        .drag-drop-area {
            border: 3px dashed #cbd5e1;
            background-color: #f8fafc;
            transition: all 0.3s ease;
        }
        .drag-drop-area.drag-over {
            border-color: #3b82f6;
            background-color: #dbeafe;
        }
        .tab-button {
            transition: all 0.3s ease;
        }
        .tab-button.active {
            background-color: #3b82f6;
            color: white;
        }
        .stats-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        .decision-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
        }
        .badge-included {
            background-color: #86efac;
            color: #166534;
        }
        .badge-excluded {
            background-color: #fca5a5;
            color: #991b1b;
        }
        .badge-pending {
            background-color: #f9fafb;
            color: #6b7280;
            border: 1px solid #e5e7eb;
        }
        .comparison-match {
            background-color: #d1fae5;
        }
        .comparison-conflict {
            background-color: #fee2e2;
        }
        .consensus-include {
            background-color: #d1fae5 !important;
            border-left: 5px solid #10b981 !important;
        }
        .consensus-exclude {
            background-color: #fee2e2 !important;
            border-left: 5px solid #ef4444 !important;
        }
        .consensus-conflict {
            background-color: #fef3c7 !important;
            border-left: 5px solid #f59e0b !important;
        }
        .consensus-pending {
            background-color: #ffffff !important;
            border-left: 5px solid #e5e7eb !important;
        }
        .reviewer-decision-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 8px;
            font-size: 11px;
            font-weight: 600;
            margin: 2px;
        }
        .reviewer-include {
            background-color: #86efac;
            color: #166534;
        }
        .reviewer-exclude {
            background-color: #fca5a5;
            color: #991b1b;
        }
        .reviewer-pending {
            background-color: #f9fafb;
            color: #6b7280;
            border: 1px solid #e5e7eb;
        }
        table {
            font-size: 14px;
        }
        td, th {
            padding: 8px;
        }
        .abstract-cell {
            max-width: 400px;
        }

        .table-container {
            position: relative;
            overflow-x: auto;
            overflow-y: visible;
            width: 100%;
        }

        #spreadsheetTable {
            width: 100%;
            min-width: 1200px;
        }

        #spreadsheetTable thead th {
            position: sticky;
            top: 0;
            background-color: #e5e7eb;
            border-bottom: 2px solid #9ca3af;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            z-index: 10;
        }

        .row-number {
            background-color: #f3f4f6;
            font-weight: bold;
            color: #6b7280;
            text-align: center;
            width: 50px;
            position: sticky;
            left: 0;
            z-index: 5;
        }

        #spreadsheetTable thead th.row-number {
            z-index: 15;
        }

        /* Decision row colors for spreadsheet and tables */
        .row-included {
            background-color: #d1fae5 !important;
            border-left: 4px solid #10b981;
        }
        .row-excluded {
            background-color: #fee2e2 !important;
            border-left: 4px solid #ef4444;
        }
        .row-pending {
            background-color: #ffffff !important;
            border-left: 4px solid #e5e7eb;
        }

        /* Decision colors for study cards */
        .card-included {
            background-color: #d1fae5;
            border-left: 4px solid #10b981;
        }
        .card-excluded {
            background-color: #fee2e2;
            border-left: 4px solid #ef4444;
        }
        .card-pending {
            background-color: #ffffff;
            border-left: 4px solid #e5e7eb;
        }

        /* Claude response preview table container */
        #claudeResponsePreview .table-container {
            overflow-x: auto;
            width: 100%;
            margin-top: 1rem;
        }

        #claudeResponsePreview table {
            min-width: 600px;
        }

        @media (max-width: 768px) {
            #claudeResponsePreview table {
                min-width: 500px;
            }
        }

        .tooltip {
            position: relative;
            display: inline-block;
        }
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 200px;
            background-color: #555;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -100px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 12px;
        }
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        .loading-content {
            background-color: white;
            padding: 40px;
            border-radius: 12px;
            text-align: center;
            max-width: 500px;
        }
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3b82f6;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #e5e7eb;
            border-radius: 10px;
            overflow: hidden;
            margin: 15px 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #8b5cf6);
            transition: width 0.3s ease;
        }
        .duplicate-card {
            border: 2px solid #f59e0b;
            background-color: #fef3c7;
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
        }
        .duplicate-item {
            border: 1px solid #d1d5db;
            background-color: white;
            padding: 12px;
            margin: 8px 0;
            border-radius: 6px;
        }
        .duplicate-item.selected {
            border-color: #3b82f6;
            background-color: #dbeafe;
        }
    </style>
</head>
<body class="bg-gray-50">
    <div class="container mx-auto p-6 max-w-7xl">
        <div class="bg-gradient-to-r from-blue-600 to-purple-600 text-white rounded-lg shadow-lg p-6 mb-6">
            <h1 class="text-3xl font-bold mb-2">Ward Academy - Systematic Review Screening Tool</h1>
            <p class="text-blue-100">Ferramenta completa para triagem de revis√µes sistem√°ticas</p>
        </div>

        <div id="uploadArea" class="drag-drop-area rounded-lg p-12 text-center mb-6">
            <div class="flex justify-end mb-4">
                <button onclick="showProjectsModal()" class="bg-purple-600 text-white px-4 py-2 rounded-lg hover:bg-purple-700 transition text-sm">
                    üìÅ Meus Projetos
                </button>
            </div>
            <svg class="mx-auto h-12 w-12 text-gray-400 mb-4" stroke="currentColor" fill="none" viewBox="0 0 48 48">
                <path d="M28 8H12a4 4 0 00-4 4v20m32-12v8m0 0v8a4 4 0 01-4 4H12a4 4 0 01-4-4v-4m32-4l-3.172-3.172a4 4 0 00-5.656 0L28 28M8 32l9.172-9.172a4 4 0 015.656 0L28 28m0 0l4 4m4-24h8m-4-4v8m-12 4h.02" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
            </svg>
            <p class="text-xl mb-2 text-gray-700">Arraste e solte um ou m√∫ltiplos arquivos aqui</p>
            <p class="text-sm text-gray-500 mb-4">ou</p>
            <label class="bg-blue-600 text-white px-6 py-3 rounded-lg cursor-pointer hover:bg-blue-700 transition inline-block">
                Selecionar Arquivo(s)
                <input type="file" id="fileInput" accept=".txt,.ris,.nbib,.ciw" multiple class="hidden">
            </label>
            <p class="text-xs text-gray-500 mt-4">Formatos aceitos: .txt, .ris, .nbib, .ciw</p>
            <p class="text-xs text-blue-600 mt-2 font-semibold">‚ú® Suporta m√∫ltiplos arquivos com deduplica√ß√£o autom√°tica!</p>
        </div>

        <div id="mainApp" class="hidden">
            <div class="grid grid-cols-1 md:grid-cols-4 gap-4 mb-6">
                <div class="stats-card rounded-lg p-4 shadow-lg">
                    <p class="text-sm opacity-90">Total de Estudos</p>
                    <p class="text-3xl font-bold" id="totalStudies">0</p>
                </div>
                <div class="bg-green-500 text-white rounded-lg p-4 shadow-lg">
                    <p class="text-sm opacity-90">Inclu√≠dos</p>
                    <p class="text-3xl font-bold" id="includedCount">0</p>
                </div>
                <div class="bg-red-500 text-white rounded-lg p-4 shadow-lg">
                    <p class="text-sm opacity-90">Exclu√≠dos</p>
                    <p class="text-3xl font-bold" id="excludedCount">0</p>
                </div>
                <div class="bg-yellow-500 text-white rounded-lg p-4 shadow-lg">
                    <p class="text-sm opacity-90">Pendentes</p>
                    <p class="text-3xl font-bold" id="pendingCount">0</p>
                </div>
            </div>

            <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
                <div class="flex justify-between items-center mb-4">
                    <div class="flex items-center gap-3">
                        <span class="text-sm font-semibold text-gray-600">Projeto:</span>
                        <span id="currentProjectName" class="text-lg font-bold text-blue-600">Sem nome</span>
                        <button onclick="renameProject()" class="text-xs text-blue-600 hover:text-blue-800 hover:underline">‚úèÔ∏è Renomear</button>
                    </div>
                    <div class="flex items-center gap-2">
                        <span id="autoSaveStatus" class="text-xs text-green-600">‚úì Auto-save ativo</span>
                        <button onclick="toggleAutoSave()" id="autoSaveToggle" class="text-xs px-2 py-1 bg-green-100 text-green-700 rounded hover:bg-green-200">ON</button>
                    </div>
                </div>

                <!-- Barra de A√ß√µes Principal -->
                <div class="flex flex-wrap gap-2 items-center">
                    <!-- Projetos -->
                    <button onclick="showProjectsModal()" class="bg-purple-600 text-white px-4 py-2 rounded-lg hover:bg-purple-700 transition text-sm font-semibold shadow-sm">
                        üìÅ Projetos
                    </button>

                    <!-- Menu Exportar/Importar -->
                    <div class="relative">
                        <button onclick="toggleDropdown('exportMenu')" class="bg-green-600 text-white px-4 py-2 rounded-lg hover:bg-green-700 transition text-sm font-semibold shadow-sm flex items-center gap-1">
                            üíæ Exportar/Importar
                            <span class="text-xs">‚ñº</span>
                        </button>
                        <div id="exportMenu" class="hidden absolute top-full left-0 mt-1 bg-white rounded-lg shadow-xl border border-gray-200 z-50 min-w-[220px]">
                            <button onclick="exportDecisions(); toggleDropdown('exportMenu')" class="w-full text-left px-4 py-2 hover:bg-gray-100 text-sm flex items-center gap-2 rounded-t-lg">
                                <span class="text-green-600">üíæ</span> Exportar Projeto Completo
                            </button>
                            <button onclick="importDecisions(); toggleDropdown('exportMenu')" class="w-full text-left px-4 py-2 hover:bg-gray-100 text-sm flex items-center gap-2 border-t">
                                <span class="text-blue-600">üì•</span> Importar Projeto
                            </button>
                            <button onclick="importAdditionalRIS(); toggleDropdown('exportMenu')" class="w-full text-left px-4 py-2 hover:bg-gray-100 text-sm flex items-center gap-2 border-t">
                                <span class="text-teal-600">‚ûï</span> Adicionar Mais Arquivos RIS
                            </button>
                            <button onclick="exportSpreadsheet(); toggleDropdown('exportMenu')" class="w-full text-left px-4 py-2 hover:bg-gray-100 text-sm flex items-center gap-2 border-t">
                                <span class="text-indigo-600">üìä</span> Baixar Planilha Excel
                            </button>
                            <button onclick="exportAsRIS(); toggleDropdown('exportMenu')" class="w-full text-left px-4 py-2 hover:bg-gray-100 text-sm flex items-center gap-2 border-t">
                                <span class="text-orange-600">üìÑ</span> Exportar como RIS
                            </button>
                            <button onclick="copyTableToClipboard(); toggleDropdown('exportMenu')" class="w-full text-left px-4 py-2 hover:bg-gray-100 text-sm flex items-center gap-2 border-t rounded-b-lg">
                                <span class="text-purple-600">üìã</span> Copiar p/ Excel
                            </button>
                        </div>
                    </div>

                    <!-- Menu Ferramentas -->
                    <div class="relative">
                        <button onclick="toggleDropdown('toolsMenu')" class="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition text-sm font-semibold shadow-sm flex items-center gap-1">
                            üõ†Ô∏è Ferramentas
                            <span class="text-xs">‚ñº</span>
                        </button>
                        <div id="toolsMenu" class="hidden absolute top-full left-0 mt-1 bg-white rounded-lg shadow-xl border border-gray-200 z-50 min-w-[220px]">
                            <button onclick="showKeywordsModal(); toggleDropdown('toolsMenu')" class="w-full text-left px-4 py-2 hover:bg-gray-100 text-sm flex items-center gap-2 rounded-t-lg">
                                <span class="text-purple-600">üîç</span> Configurar Keywords
                            </button>
                            <button onclick="showCompareModal(); toggleDropdown('toolsMenu')" class="w-full text-left px-4 py-2 hover:bg-gray-100 text-sm flex items-center gap-2 border-t">
                                <span class="text-orange-600">üîÑ</span> Comparar Revisores
                            </button>
                            <button onclick="showClaudeCommandModal(); toggleDropdown('toolsMenu')" class="w-full text-left px-4 py-2 hover:bg-gray-100 text-sm flex items-center gap-2 border-t rounded-b-lg">
                                <span class="bg-gradient-to-r from-pink-500 to-purple-600 bg-clip-text text-transparent">ü§ñ</span> Comando Claude AI
                            </button>
                        </div>
                    </div>

                    <!-- Bot√£o Salvar (aparece apenas no modo compara√ß√£o) -->
                    <button id="saveNewReviewerDecisionsBtn" onclick="saveNewReviewerDecisions()" class="hidden bg-gradient-to-r from-green-500 to-teal-600 text-white px-4 py-2 rounded-lg hover:from-green-600 hover:to-teal-700 transition font-semibold shadow-sm">
                        ‚úÖ Salvar Minhas Decis√µes
                    </button>
                </div>
            </div>

            <div class="bg-white rounded-lg shadow-lg mb-6">
                <div class="flex border-b">
                    <button onclick="switchTab('spreadsheet')" id="tabSpreadsheet" class="tab-button active flex-1 px-6 py-3 font-semibold">
                        üìä Modo Planilha
                    </button>
                    <button onclick="switchTab('screening')" id="tabScreening" class="tab-button flex-1 px-6 py-3 font-semibold text-gray-600 hover:bg-gray-100">
                        üîç Modo Triagem
                    </button>
                </div>

                <div id="spreadsheetView" class="p-6">
                    <div class="mb-4">
                        <div class="flex gap-3 mb-3">
                            <button onclick="toggleAllAbstracts()" id="toggleAbstractsBtn" class="bg-gray-600 text-white px-4 py-2 rounded hover:bg-gray-700 transition text-sm">
                                üëÅÔ∏è Mostrar Abstracts
                            </button>
                            <select id="filterSpreadsheet" onchange="applyFilters()" class="border rounded px-4 py-2 text-sm">
                                <option value="all">Todos os Estudos</option>
                                <option value="included">Apenas Inclu√≠dos</option>
                                <option value="excluded">Apenas Exclu√≠dos</option>
                                <option value="pending">Apenas Pendentes</option>
                            </select>
                            <select id="comparisonMainFilter" onchange="applyComparisonMainFilter()" class="border rounded px-4 py-2 text-sm hidden">
                                <option value="comp-all">üìã Todos</option>
                                <option value="comp-consensus-include">üü¢ Consenso Inclus√£o</option>
                                <option value="comp-consensus-exclude">üî¥ Consenso Exclus√£o</option>
                                <option value="comp-conflict">‚ö†Ô∏è Conflitos</option>
                                <option value="comp-pending">‚ö™ Com Pend√™ncias</option>
                            </select>
                            <button onclick="toggleSearchHelp()" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600 transition text-sm">
                                ‚ùì Ajuda
                            </button>
                            <div id="comparisonModeIndicator" class="hidden ml-auto flex gap-2">
                                <button onclick="showComparisonFiltersInMain()" class="bg-gradient-to-r from-orange-500 to-red-500 text-white px-4 py-2 rounded hover:from-orange-600 hover:to-red-600 transition text-sm font-semibold">
                                    üîÑ Modo Compara√ß√£o Ativo
                                </button>
                                <button id="toggleReviewersVisibility" onclick="toggleOtherReviewersVisibility()" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 transition text-sm font-semibold">
                                    üëÅÔ∏è Mostrar Decis√µes dos Outros
                                </button>
                            </div>
                        </div>

                        <div class="mb-3">
                            <!-- Toggle Switch for Advanced Search -->
                            <div class="flex items-center gap-3 mb-3">
                                <span class="text-sm font-semibold text-gray-700">Modo de Busca:</span>
                                <label class="relative inline-flex items-center cursor-pointer">
                                    <input type="checkbox" id="advancedSearchToggle" class="sr-only peer" checked onchange="toggleSearchMode()">
                                    <div class="w-14 h-7 bg-gray-300 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[4px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-6 after:w-6 after:transition-all peer-checked:bg-blue-600"></div>
                                    <span class="ml-3 text-sm font-medium text-gray-700">
                                        <span id="searchModeLabel">Busca Avan√ßada</span>
                                    </span>
                                </label>
                                <button onclick="toggleSearchHelp()" class="text-blue-600 hover:text-blue-800 text-sm font-semibold">
                                    ‚ùì Ajuda
                                </button>
                            </div>

                            <div class="flex gap-2">
                                <input type="text"
                                    id="searchInput"
                                    placeholder='üîç Busca avan√ßada: diabetes AND (treatment OR therapy) NOT "case report" author:Smith'
                                    class="flex-1 border rounded px-4 py-2 text-sm"
                                    onkeyup="performSearch()">
                                <button onclick="clearSearch()" class="bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600 transition text-sm">
                                    ‚úñ Limpar
                                </button>
                            </div>

                            <!-- Advanced Search Help -->
                            <div id="searchHelpAdvanced" class="hidden mt-2 bg-blue-50 p-3 rounded text-xs">
                                <p class="font-semibold mb-2">üìñ Operadores de Busca Avan√ßada:</p>
                                <ul class="space-y-1 text-gray-700">
                                    <li><strong>AND</strong> - Todos os termos devem existir: <code>diabetes AND insulin</code></li>
                                    <li><strong>OR</strong> - Qualquer termo pode existir: <code>treatment OR therapy</code></li>
                                    <li><strong>NOT</strong> - Exclui termo: <code>surgery NOT pediatric</code></li>
                                    <li><strong>"aspas"</strong> - Busca exata: <code>"randomized controlled trial"</code></li>
                                    <li><strong>*</strong> - Wildcard: <code>surg* (surgery, surgical, surgeon)</code></li>
                                    <li><strong>( )</strong> - Agrupamento: <code>diabetes AND (type1 OR type2)</code></li>
                                    <li><strong>Campos espec√≠ficos:</strong> <code>title:USMLE</code>, <code>author:Smith</code>, <code>year:2024</code>, <code>abstract:failure</code></li>
                                </ul>
                                <p class="mt-2 text-gray-600">Busca em: T√≠tulo, Autores, Ano, Abstract, Observations</p>
                            </div>

                            <!-- Simple Search Help -->
                            <div id="searchHelpSimple" class="hidden mt-2 bg-green-50 p-3 rounded text-xs">
                                <p class="font-semibold mb-2">üìñ Busca Simples:</p>
                                <p class="text-gray-700 mb-2">Digite palavras-chave e a busca encontrar√° estudos que contenham qualquer uma delas.</p>
                                <ul class="space-y-1 text-gray-700">
                                    <li>‚úì Busca <strong>case-insensitive</strong> (ignora mai√∫sculas/min√∫sculas)</li>
                                    <li>‚úì Busca em todos os campos: T√≠tulo, Autores, Ano, Abstract, Observations</li>
                                    <li>‚úì Separe palavras com espa√ßo: <code>diabetes treatment insulin</code></li>
                                    <li>‚úì Quanto mais palavras, mais estudos ser√£o encontrados</li>
                                </ul>
                                <p class="mt-2 text-gray-600 italic">Dica: Use a Busca Avan√ßada para mais controle com operadores AND, OR, NOT</p>
                            </div>
                            
                            <div id="searchResults" class="mt-2 text-sm font-semibold">
                                <span class="text-gray-700">Resultados: </span>
                                <span id="searchCount" class="text-blue-600">0 estudos encontrados</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="table-container">
                        <table class="w-full border-collapse border" id="spreadsheetTable">
                            <thead class="bg-gray-100">
                                <tr>
                                    <th class="border p-2 row-number">#</th>
                                    <th class="border p-2">STUDY ID</th>
                                    <th class="border p-2">DOI LINK</th>
                                    <th class="border p-2">TITLE</th>
                                    <th class="border p-2">AUTHOR</th>
                                    <th class="border p-2">YEAR</th>
                                    <th class="border p-2">ABSTRACT</th>
                                    <th class="border p-2">PDF FOUND?</th>
                                    <th class="border p-2">INCLUDED</th>
                                    <th class="border p-2">EXCLUDED</th>
                                    <th class="border p-2">REASON FOR EXCLUSION</th>
                                    <th class="border p-2">OBSERVATIONS</th>
                                </tr>
                            </thead>
                            <tbody id="spreadsheetBody">
                            </tbody>
                        </table>
                    </div>
                </div>

                <div id="screeningView" class="p-6 hidden">
                    <div class="flex gap-6">
                        <div class="w-1/3 border-r pr-4">
                            <div class="mb-4">
                                <input type="text"
                                    id="searchInputScreening"
                                    placeholder='üîç Busca: diabetes AND treatment'
                                    class="w-full border rounded px-3 py-2 text-sm mb-2"
                                    onkeyup="performSearch()">
                                <select id="filterScreening" onchange="applyFilters()" class="w-full border rounded px-4 py-2 text-sm mb-2">
                                    <option value="all">Todos os Estudos</option>
                                    <option value="included">Apenas Inclu√≠dos</option>
                                    <option value="excluded">Apenas Exclu√≠dos</option>
                                    <option value="pending">Apenas Pendentes</option>
                                </select>
                                <select id="comparisonScreeningFilter" onchange="applyComparisonMainFilter()" class="w-full border rounded px-4 py-2 text-sm mb-2 hidden">
                                    <option value="comp-all">üìã Todos</option>
                                    <option value="comp-consensus-include">üü¢ Consenso Inclus√£o</option>
                                    <option value="comp-consensus-exclude">üî¥ Consenso Exclus√£o</option>
                                    <option value="comp-conflict">‚ö†Ô∏è Conflitos</option>
                                    <option value="comp-pending">‚ö™ Com Pend√™ncias</option>
                                </select>
                                
                                <div class="text-sm font-semibold mb-2">
                                    <span class="text-gray-700">Resultados: </span>
                                    <span id="searchCountScreening" class="text-blue-600">0 estudos</span>
                                </div>
                            </div>
                            <div id="studyList" class="space-y-2 max-h-[600px] overflow-y-auto">
                            </div>
                        </div>

                        <div class="w-2/3">
                            <div id="studyDetails" class="text-gray-500 text-center py-12">
                                Selecione um ou mais estudos para revisar
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Loading Overlay -->
        <div id="loadingOverlay" class="loading-overlay" style="display: none;">
            <div class="loading-content">
                <div class="spinner"></div>
                <h2 class="text-2xl font-bold mb-3" id="loadingTitle">Processando arquivos...</h2>
                <p class="text-gray-600 mb-4" id="loadingMessage">Analisando dados...</p>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressBar" style="width: 0%"></div>
                </div>
                <p class="text-sm text-gray-500 mt-2" id="progressText">0%</p>
            </div>
        </div>

        <!-- DOI Deduplication Modal -->
        <div id="doiDeduplicationModal" class="modal">
            <div class="modal-content">
                <span class="close" onclick="closeDoiDeduplicationModal()">&times;</span>
                <h2 class="text-2xl font-bold mb-4">üîç Duplicados encontrados por DOI</h2>
                <p class="text-gray-600 mb-4">Foram encontrados <span id="doiDuplicateCount" class="font-bold text-red-600">0</span> grupos de artigos duplicados baseados no DOI.</p>

                <div class="flex gap-3 mb-4">
                    <button onclick="removeAllDoiDuplicates()" class="bg-red-600 text-white px-6 py-2 rounded-lg hover:bg-red-700 transition font-semibold">
                        üóëÔ∏è Remover Todos os Duplicados (manter apenas 1 de cada)
                    </button>
                    <button onclick="keepAllDoiDuplicates()" class="bg-gray-600 text-white px-6 py-2 rounded-lg hover:bg-gray-700 transition font-semibold">
                        ‚úÖ Manter Todos e Prosseguir
                    </button>
                </div>

                <div id="doiDuplicatesList" class="space-y-4">
                </div>

                <div class="mt-6 text-center">
                    <button onclick="proceedToTitleDeduplication()" class="bg-green-600 text-white px-8 py-3 rounded-lg hover:bg-green-700 transition font-semibold text-lg">
                        ‚û°Ô∏è Prosseguir para Deduplica√ß√£o por T√≠tulo
                    </button>
                </div>
            </div>
        </div>

        <!-- Title Deduplication Modal -->
        <div id="titleDeduplicationModal" class="modal">
            <div class="modal-content">
                <span class="close" onclick="closeTitleDeduplicationModal()">&times;</span>
                <h2 class="text-2xl font-bold mb-4">üìù Poss√≠veis duplicados encontrados por T√≠tulo</h2>
                <p class="text-gray-600 mb-4">Foram encontrados <span id="titleDuplicateCount" class="font-bold text-orange-600">0</span> grupos de artigos com t√≠tulos similares.</p>

                <div class="flex gap-3 mb-4">
                    <button onclick="removeAllTitleDuplicates()" class="bg-red-600 text-white px-6 py-2 rounded-lg hover:bg-red-700 transition font-semibold">
                        üóëÔ∏è Remover Todos os Duplicados (manter apenas 1 de cada)
                    </button>
                    <button onclick="keepAllTitleDuplicates()" class="bg-gray-600 text-white px-6 py-2 rounded-lg hover:bg-gray-700 transition font-semibold">
                        ‚úÖ Manter Todos e Prosseguir
                    </button>
                </div>

                <div id="titleDuplicatesList" class="space-y-4">
                </div>

                <div class="mt-6 text-center">
                    <button onclick="finishDeduplication()" class="bg-green-600 text-white px-8 py-3 rounded-lg hover:bg-green-700 transition font-semibold text-lg">
                        ‚úÖ Finalizar e Iniciar Projeto
                    </button>
                </div>
            </div>
        </div>

        <!-- Files Confirmation Modal -->
        <div id="filesConfirmationModal" class="modal">
            <div class="modal-content">
                <h2 class="text-2xl font-bold mb-4">üìÇ Arquivos Carregados</h2>
                <p class="text-gray-600 mb-4">Foram carregados <span id="totalArticlesLoaded" class="font-bold text-blue-600">0</span> artigos de <span id="totalFilesLoaded" class="font-bold text-blue-600">0</span> arquivos.</p>

                <div id="filesListConfirmation" class="space-y-3 mb-6">
                </div>

                <div class="bg-yellow-50 border-l-4 border-yellow-400 p-4 mb-4" id="noYearWarning" style="display: none;">
                    <div class="flex">
                        <div class="flex-shrink-0">
                            <svg class="h-5 w-5 text-yellow-400" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
                            </svg>
                        </div>
                        <div class="ml-3">
                            <p class="text-sm text-yellow-700">
                                ‚ö†Ô∏è <span id="noYearCount" class="font-bold">0</span> artigos n√£o possuem ano de publica√ß√£o. Estes artigos podem causar problemas durante a revis√£o.
                            </p>
                        </div>
                    </div>
                </div>

                <div class="mt-6 text-center">
                    <button onclick="proceedFromFilesConfirmation()" id="confirmFilesButton" class="bg-green-600 text-white px-8 py-3 rounded-lg hover:bg-green-700 transition font-semibold text-lg">
                        ‚úÖ Confirmar e Prosseguir
                    </button>
                </div>
            </div>
        </div>

        <!-- Calibration Modal -->
        <div id="calibrationModal" class="modal">
            <div class="modal-content" style="max-width: 95%; max-height: 95vh; display: flex; flex-direction: column;">
                <div class="flex justify-between items-center mb-3">
                    <h2 class="text-2xl font-bold">üîß Calibra√ß√£o de Parser RIS</h2>
                    <button onclick="closeCalibrationModal()" class="text-gray-500 hover:text-gray-700 text-2xl">&times;</button>
                </div>

                <p class="text-gray-600 mb-3">
                    Arquivo: <span id="calibrationFileName" class="font-bold text-blue-600"></span>
                </p>

                <div class="bg-blue-50 border-l-4 border-blue-400 p-4 mb-3">
                    <p class="text-sm text-blue-900 font-semibold mb-2">üìö COMO USAR ESTA FERRAMENTA:</p>
                    <ol class="text-xs text-blue-800 space-y-1 ml-4 list-decimal">
                        <li><strong>Clique em um campo</strong> (T√≠tulo, Autor, etc.) para ativ√°-lo</li>
                        <li><strong>Selecione APENAS a tag/indicador</strong> no texto abaixo (exemplo: selecione s√≥ "T1  -" ou "TI  -")</li>
                        <li><strong>N√ÉO selecione o conte√∫do</strong>, apenas o marcador que identifica o campo</li>
                        <li>Repita para 2-3 exemplos de cada campo que voc√™ quer calibrar</li>
                        <li>Clique em <strong>"üß™ Testar"</strong> para ver se funcionou</li>
                        <li>Se estiver OK, clique em <strong>"‚úÖ Aplicar"</strong></li>
                    </ol>
                </div>

                <div class="bg-yellow-50 border-l-4 border-yellow-400 p-3 mb-3">
                    <p class="text-xs text-yellow-900">
                        <strong>‚ö†Ô∏è IMPORTANTE:</strong> Selecione <strong>SOMENTE</strong> o indicador/tag (ex: "TI  -", "AU  -", "Y1  -").<br>
                        ‚ùå <strong>ERRADO:</strong> Selecionar "TI  - Effects of cognitive training on memory"<br>
                        ‚úÖ <strong>CERTO:</strong> Selecionar apenas "TI  -"
                    </p>
                </div>

                <div class="grid grid-cols-3 gap-4 mb-3">
                    <div class="flex flex-col">
                        <h3 class="font-semibold mb-2 text-sm">1Ô∏è‚É£ Selecione o campo:</h3>
                        <div class="space-y-2">
                            <button onclick="setCalibrationMode('type')" id="calibBtn_type" class="w-full text-left px-3 py-2 rounded bg-gray-100 hover:bg-purple-100 text-sm">
                                üî¥ In√≠cio de Artigo (TY)
                            </button>
                            <button onclick="setCalibrationMode('title')" id="calibBtn_title" class="w-full text-left px-3 py-2 rounded bg-gray-100 hover:bg-purple-100 text-sm">
                                üìÑ T√≠tulo (TI/T1/ST)
                            </button>
                            <button onclick="setCalibrationMode('author')" id="calibBtn_author" class="w-full text-left px-3 py-2 rounded bg-gray-100 hover:bg-purple-100 text-sm">
                                üë§ Autor (AU/A1/FAU)
                            </button>
                            <button onclick="setCalibrationMode('year')" id="calibBtn_year" class="w-full text-left px-3 py-2 rounded bg-gray-100 hover:bg-purple-100 text-sm">
                                üìÖ Ano (PY/Y1/DA)
                            </button>
                            <button onclick="setCalibrationMode('doi')" id="calibBtn_doi" class="w-full text-left px-3 py-2 rounded bg-gray-100 hover:bg-purple-100 text-sm">
                                üîó DOI (DO/M3)
                            </button>
                            <button onclick="setCalibrationMode('abstract')" id="calibBtn_abstract" class="w-full text-left px-3 py-2 rounded bg-gray-100 hover:bg-purple-100 text-sm">
                                üìù Abstract (AB/N2)
                            </button>
                        </div>
                        <div class="mt-3 p-2 bg-purple-50 rounded border border-purple-200">
                            <p class="text-xs font-semibold text-purple-900">Campo ativo:</p>
                            <p id="currentCalibMode" class="text-sm text-purple-600 font-bold">Nenhum</p>
                        </div>

                        <div class="mt-4">
                            <h3 class="font-semibold mb-2 text-sm">2Ô∏è‚É£ Exemplos capturados:</h3>
                            <div id="calibrationExamples" class="text-xs space-y-1 bg-gray-50 p-3 rounded border border-gray-300 overflow-y-auto" style="max-height: 280px;">
                                <p class="text-gray-400 italic">Nenhum exemplo ainda...</p>
                            </div>
                        </div>
                    </div>

                    <div class="col-span-2 flex flex-col">
                        <div class="flex justify-between items-center mb-2">
                            <h3 class="font-semibold text-sm">3Ô∏è‚É£ Conte√∫do do arquivo (primeiras 200 linhas):</h3>
                            <div class="flex gap-2 text-xs flex-wrap">
                                <span class="px-2 py-1 rounded" style="background-color: #ef444420; color: #ef4444; font-weight: bold;">üî¥ In√≠cio</span>
                                <span class="px-2 py-1 rounded" style="background-color: #3b82f620; color: #3b82f6; font-weight: bold;">üìÑ T√≠tulo</span>
                                <span class="px-2 py-1 rounded" style="background-color: #8b5cf620; color: #8b5cf6; font-weight: bold;">üë§ Autor</span>
                                <span class="px-2 py-1 rounded" style="background-color: #10b98120; color: #10b981; font-weight: bold;">üìÖ Ano</span>
                                <span class="px-2 py-1 rounded" style="background-color: #f59e0b20; color: #f59e0b; font-weight: bold;">üîó DOI</span>
                                <span class="px-2 py-1 rounded" style="background-color: #6366f120; color: #6366f1; font-weight: bold;">üìù Abstract</span>
                            </div>
                        </div>
                        <div
                            id="calibrationText"
                            class="w-full font-mono text-xs border-2 border-gray-300 rounded p-3 overflow-y-auto bg-white"
                            style="height: 500px; max-height: 500px; white-space: pre; cursor: text; user-select: text;"
                        ></div>
                    </div>
                </div>

                <div id="calibrationTestResult" class="bg-green-50 border-l-4 border-green-400 p-3 mb-3" style="display: none;">
                    <p class="text-sm font-semibold text-green-900 mb-2">üß™ Resultado do Teste:</p>
                    <div id="calibrationTestContent" class="text-xs text-green-800"></div>
                </div>

                <div class="flex justify-between items-center pt-3 border-t">
                    <button onclick="clearCalibration()" class="bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600">
                        üóëÔ∏è Limpar Tudo
                    </button>
                    <div class="flex gap-2">
                        <button onclick="testCalibration()" class="bg-blue-600 text-white px-5 py-2 rounded hover:bg-blue-700 font-semibold">
                            üß™ Testar Calibra√ß√£o
                        </button>
                        <button onclick="closeCalibrationModal()" class="bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600">
                            Cancelar
                        </button>
                        <button onclick="applyCalibration()" class="bg-green-600 text-white px-6 py-2 rounded hover:bg-green-700 font-semibold">
                            ‚úÖ Aplicar Calibra√ß√£o
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <div id="keywordsModal" class="modal">
            <div class="modal-content">
                <span class="close" onclick="closeKeywordsModal()">&times;</span>
                <h2 class="text-2xl font-bold mb-6">Configurar Keywords para Highlight</h2>
                
                <div class="mb-6">
                    <label class="block font-semibold mb-2">üü¢ Keywords para INCLUIR (highlight verde)</label>
                    <textarea id="includeKeywords" class="w-full border rounded p-3 h-24" placeholder="Digite as palavras separadas por v√≠rgula&#10;Ex: randomized controlled trial, meta-analysis, cohort study"></textarea>
                    <p class="text-xs text-gray-500 mt-1">Use v√≠rgula para separar. Use * para varia√ß√µes (ex: random*)</p>
                </div>

                <div class="mb-6">
                    <label class="block font-semibold mb-2">üî¥ Keywords para EXCLUIR (highlight vermelho)</label>
                    <textarea id="excludeKeywords" class="w-full border rounded p-3 h-24" placeholder="Digite as palavras separadas por v√≠rgula&#10;Ex: case report, editorial, letter, animal study"></textarea>
                    <p class="text-xs text-gray-500 mt-1">Use v√≠rgula para separar. Use * para varia√ß√µes (ex: animal*)</p>
                </div>

                <div class="mb-6">
                    <label class="block font-semibold mb-2">üü° Keywords de METODOLOGIA (highlight amarelo)</label>
                    <textarea id="methodsKeywords" class="w-full border rounded p-3 h-24" placeholder="Padr√£o: introduction, method*, result*, conclusion*, background, discussion"></textarea>
                    <p class="text-xs text-gray-500 mt-1">Use v√≠rgula para separar. Use * para varia√ß√µes</p>
                </div>

                <button onclick="applyKeywords()" class="w-full bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700 transition font-semibold">
                    Aplicar Keywords
                </button>
            </div>
        </div>

        <div id="compareModal" class="modal">
            <div class="modal-content" style="max-width: 1200px;">
                <span class="close" onclick="closeCompareModal()">&times;</span>
                <h2 class="text-2xl font-bold mb-6">üîÑ Comparar Decis√µes de Revisores</h2>
                
                <div class="mb-4">
                    <p class="text-sm text-gray-600 mb-3">Selecione 2 ou mais arquivos de decis√µes para comparar:</p>
                    <input type="file" id="compareFiles" accept=".json" multiple class="w-full border rounded p-2 mb-3">

                    <div class="bg-blue-50 border-2 border-blue-200 rounded-lg p-4 mb-3">
                        <label class="block font-semibold mb-2 text-sm">üë§ Seu Nome (Novo Revisor):</label>
                        <input type="text" id="newReviewerNameInput" placeholder="Digite seu nome para iniciar a triagem..." class="w-full border rounded px-4 py-2 mb-2">
                        <p class="text-xs text-gray-600">üí° Voc√™ poder√° revisar os artigos e dar sua opini√£o ap√≥s carregar os arquivos dos outros revisores</p>
                    </div>

                    <button onclick="compareReviewers()" class="w-full bg-orange-600 text-white px-6 py-3 rounded-lg hover:bg-orange-700 transition font-semibold">
                        üîç Iniciar Sess√£o de Compara√ß√£o
                    </button>
                </div>

                <div id="comparisonResults" class="mt-6 hidden">
                    <!-- Summary Stats -->
                    <div class="bg-gradient-to-r from-purple-50 to-blue-50 p-6 rounded-lg mb-6">
                        <h3 class="font-bold text-xl mb-4">üìä Resumo da Compara√ß√£o</h3>
                        <div id="comparisonSummary"></div>
                    </div>

                    <!-- Filters and Export Controls -->
                    <div class="bg-white border-2 border-blue-200 rounded-lg p-6 mb-6">
                        <h3 class="font-bold text-lg mb-4">üéØ Filtros e Exporta√ß√£o</h3>
                        
                        <!-- Comparison Filters -->
                        <div class="mb-4">
                            <label class="block font-semibold mb-2 text-sm">Filtrar por tipo de concord√¢ncia:</label>
                            <select id="comparisonFilterSelect" onchange="applyComparisonFilter()" class="w-full border rounded px-4 py-2">
                                <option value="all">üìã Todos os estudos</option>
                                <option value="full-agreement">‚úÖ Concord√¢ncia Total (todos concordam)</option>
                                <option value="full-include">üü¢ Todos concordam em INCLUIR</option>
                                <option value="full-exclude">üî¥ Todos concordam em EXCLUIR</option>
                                <option value="conflicts">‚ö†Ô∏è Discord√¢ncias (conflitos)</option>
                                <option value="majority-include">üìà Maioria vota INCLUIR</option>
                                <option value="majority-exclude">üìâ Maioria vota EXCLUIR</option>
                                <option value="with-pending">‚ö™ Artigos com pend√™ncias</option>
                            </select>
                        </div>

                        <!-- Individual Reviewer Filters -->
                        <div class="mb-4" id="individualReviewerFilters">
                            <label class="block font-semibold mb-2 text-sm">Filtrar por revisor espec√≠fico:</label>
                            <div class="grid grid-cols-1 gap-2" id="reviewerFilterOptions">
                                <!-- Will be populated dynamically -->
                            </div>
                        </div>

                        <!-- Reviewer Selection for Export -->
                        <div class="mb-4">
                            <label class="block font-semibold mb-2 text-sm">Selecione revisores para an√°lise espec√≠fica:</label>
                            <div id="reviewerCheckboxes" class="grid grid-cols-2 gap-2 mb-3">
                                <!-- Checkboxes will be dynamically inserted -->
                            </div>
                            <button onclick="applyReviewerSelection()" class="bg-blue-500 text-white px-4 py-2 rounded text-sm hover:bg-blue-600">
                                üîÑ Aplicar Sele√ß√£o
                            </button>
                        </div>

                        <!-- Export Buttons -->
                        <div class="border-t pt-4 mt-4">
                            <label class="block font-semibold mb-3 text-sm">üíæ Exportar Planilha Filtrada:</label>
                            <div class="grid grid-cols-2 gap-2 mb-3">
                                <button onclick="exportComparisonSpreadsheet('current-filter')" class="bg-green-600 text-white px-4 py-2 rounded text-sm hover:bg-green-700">
                                    üìä Exportar Filtro Atual
                                </button>
                                <button onclick="exportComparisonSpreadsheet('selected-reviewers')" class="bg-indigo-600 text-white px-4 py-2 rounded text-sm hover:bg-indigo-700">
                                    üë• Exportar Revisores Selecionados
                                </button>
                                <button onclick="exportComparisonSpreadsheet('consensus')" class="bg-purple-600 text-white px-4 py-2 rounded text-sm hover:bg-purple-700">
                                    ü§ù Exportar Consenso Total
                                </button>
                                <button onclick="exportComparisonSpreadsheet('conflicts-only')" class="bg-red-600 text-white px-4 py-2 rounded text-sm hover:bg-red-700">
                                    ‚ö†Ô∏è Exportar Apenas Conflitos
                                </button>
                            </div>
                            <button onclick="showAdvancedExportModal()" class="w-full bg-gradient-to-r from-blue-600 to-indigo-600 text-white px-4 py-3 rounded text-sm hover:from-blue-700 hover:to-indigo-700 font-semibold">
                                ‚öôÔ∏è Exporta√ß√£o Avan√ßada (Selecionar Revisores e Crit√©rios)
                            </button>
                        </div>
                    </div>

                    <!-- Detailed Comparison Table -->
                    <div class="bg-white rounded-lg border">
                        <div class="p-4 bg-gray-50 border-b">
                            <h3 class="font-bold text-lg">üìã An√°lise Detalhada</h3>
                            <p class="text-sm text-gray-600 mt-1">
                                Mostrando <span id="filteredStudiesCount" class="font-bold text-blue-600">0</span> estudos
                            </p>
                        </div>
                        <div id="detailedComparisonTable" class="max-h-[500px] overflow-y-auto">
                            <!-- Detailed comparison will be rendered here -->
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="advancedExportModal" class="modal">
            <div class="modal-content" style="max-width: 800px;">
                <span class="close" onclick="closeAdvancedExportModal()">&times;</span>
                <h2 class="text-2xl font-bold mb-6">‚öôÔ∏è Exporta√ß√£o Avan√ßada</h2>

                <div class="bg-blue-50 border-2 border-blue-200 rounded-lg p-4 mb-4">
                    <p class="text-sm text-gray-700">
                        <strong>üí° Como funciona:</strong> Selecione os revisores e o tipo de consenso que voc√™ deseja exportar.
                        Por exemplo, voc√™ pode exportar apenas os artigos onde os Revisores 1 e 2 concordam em incluir.
                    </p>
                </div>

                <div class="mb-4">
                    <label class="block font-semibold mb-3 text-sm">üë• Selecione os Revisores:</label>
                    <div id="advancedExportReviewersList" class="grid grid-cols-2 gap-2 mb-3">
                        <!-- Will be populated dynamically -->
                    </div>
                </div>

                <div class="mb-4">
                    <label class="block font-semibold mb-3 text-sm">üìã Tipo de Consenso:</label>
                    <select id="advancedExportConsensusType" class="w-full border rounded px-4 py-2">
                        <option value="all-agree-include">‚úÖ Todos os selecionados concordam em INCLUIR</option>
                        <option value="all-agree-exclude">‚ùå Todos os selecionados concordam em EXCLUIR</option>
                        <option value="all-agree-any">ü§ù Todos os selecionados concordam (incluir OU excluir)</option>
                        <option value="any-include">‚úÖ Pelo menos um selecionado incluiu</option>
                        <option value="any-exclude">‚ùå Pelo menos um selecionado excluiu</option>
                        <option value="majority-include">üìä Maioria dos selecionados incluiu</option>
                        <option value="majority-exclude">üìä Maioria dos selecionados excluiu</option>
                    </select>
                </div>

                <div class="mb-4">
                    <label class="block font-semibold mb-2 text-sm">üíæ Nome do Arquivo (Opcional):</label>
                    <input type="text" id="advancedExportFilename" placeholder="Deixe em branco para nome autom√°tico" class="w-full border rounded px-4 py-2">
                </div>

                <div class="bg-gray-50 border rounded-lg p-4 mb-4">
                    <p class="text-sm text-gray-700">
                        <strong>üìä Preview:</strong>
                        <span id="advancedExportPreview" class="text-blue-600 font-semibold">Selecione os crit√©rios acima</span>
                    </p>
                </div>

                <div class="flex gap-3">
                    <button onclick="executeAdvancedExport()" class="flex-1 bg-green-600 text-white px-6 py-3 rounded-lg hover:bg-green-700 transition font-semibold">
                        üíæ Exportar Planilha
                    </button>
                    <button onclick="closeAdvancedExportModal()" class="bg-gray-500 text-white px-6 py-3 rounded-lg hover:bg-gray-600 transition">
                        Cancelar
                    </button>
                </div>
            </div>
        </div>

        <div id="claudeCommandModal" class="modal">
            <div class="modal-content" style="max-width: 900px;">
                <span class="close" onclick="closeClaudeCommandModal()">&times;</span>
                <h2 class="text-2xl font-bold mb-6">ü§ñ Comando para Claude AI</h2>
                
                <div class="mb-4">
                    <label class="block font-semibold mb-2">Filtrar Estudos por Status</label>
                    <select id="claudeCommandFilter" class="w-full border rounded px-4 py-2 mb-3" onchange="updateClaudeCommandFilter()">
                        <option value="all">üìö Todos os Estudos</option>
                        <option value="pending">‚ö™ Apenas Pendentes</option>
                        <option value="included">‚úÖ Apenas Inclu√≠dos</option>
                        <option value="excluded">‚ùå Apenas Exclu√≠dos</option>
                    </select>
                    <div id="filterInfo" class="text-xs text-blue-600 mb-3 hidden">
                        <!-- Info sobre estudos filtrados -->
                    </div>
                </div>

                <div class="mb-4">
                    <label class="block font-semibold mb-2">Intervalo de Estudos</label>
                    <div class="flex gap-3 items-center flex-wrap">
                        <input type="number" id="rangeStart" min="1" placeholder="De" class="border rounded px-3 py-2 w-24">
                        <span>at√©</span>
                        <input type="number" id="rangeEnd" min="1" placeholder="At√©" class="border rounded px-3 py-2 w-24">
                        <span class="text-sm text-gray-500" id="rangeInfo"></span>
                    </div>
                    <p class="text-xs text-gray-500 mt-2">
                        üí° O intervalo se refere aos estudos <strong>ap√≥s aplicar o filtro</strong> acima.
                        Ex: Se filtrar "Pendentes" e houver 10 pendentes, use 1 a 10.
                    </p>
                </div>

                <div class="mb-4">
                    <div class="flex justify-between items-center mb-2">
                        <label class="block font-semibold">Framework PICO/PECO (Personaliz√°vel)</label>
                        <div class="flex gap-2">
                            <button onclick="addPicoField()" class="text-xs bg-green-500 text-white px-3 py-1 rounded hover:bg-green-600">
                                ‚ûï Adicionar Campo
                            </button>
                            <button onclick="resetPicoFields()" class="text-xs bg-gray-500 text-white px-3 py-1 rounded hover:bg-gray-600">
                                üîÑ Resetar
                            </button>
                        </div>
                    </div>
                    <div id="picoFieldsContainer">
                    </div>
                </div>

                <div class="flex gap-3 mb-4">
                    <button onclick="generateClaudeCommand()" class="flex-1 bg-gradient-to-r from-pink-500 to-purple-600 text-white px-6 py-3 rounded-lg hover:from-pink-600 hover:to-purple-700 transition font-semibold">
                        üìã Copiar Comando para Claude
                    </button>
                    <button onclick="showClaudeResponseParser()" class="flex-1 bg-gradient-to-r from-blue-500 to-indigo-600 text-white px-6 py-3 rounded-lg hover:from-blue-600 hover:to-indigo-700 transition font-semibold">
                        üì• Colar Resposta do Claude
                    </button>
                </div>

                <div id="claudeCommandOutput" class="mt-4 hidden">
                    <label class="block font-semibold mb-2">Comando Gerado (Copiado!)</label>
                    <textarea id="claudeCommandText" class="w-full border rounded p-3 h-64 font-mono text-xs" readonly></textarea>
                </div>
            </div>
        </div>

        <div id="claudeResponseModal" class="modal">
            <div class="modal-content" style="max-width: 1000px;">
                <span class="close" onclick="closeClaudeResponseModal()">&times;</span>
                <h2 class="text-2xl font-bold mb-6">üì• Processar Resposta do Claude AI</h2>
                
                <div class="mb-4 bg-blue-50 p-4 rounded-lg">
                    <p class="text-sm text-blue-800 mb-2">
                        <strong>üí° Como usar:</strong>
                    </p>
                    <ol class="text-xs text-blue-700 list-decimal list-inside space-y-1">
                        <li>Cole a resposta completa do Claude (pode incluir texto antes/depois da tabela)</li>
                        <li>O app extrai automaticamente a tabela com decis√µes</li>
                        <li>Revise o preview das decis√µes</li>
                        <li>Clique "Aplicar Decis√µes" para atualizar seus estudos</li>
                    </ol>
                </div>

                <div class="mb-4">
                    <label class="block font-semibold mb-2">Cole a resposta do Claude aqui:</label>
                    <textarea id="claudeResponseInput" class="w-full border rounded p-3 h-48 font-mono text-xs" placeholder="Cole toda a resposta do Claude aqui (incluindo a tabela)..."></textarea>
                </div>

                <button onclick="parseClaudeResponse()" class="w-full bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700 transition font-semibold mb-4">
                    üîç Processar Resposta
                </button>

                <div id="claudeResponsePreview" class="hidden">
                    <div class="mb-4 bg-purple-50 p-4 rounded-lg">
                        <label class="block font-semibold mb-2">üìä Selecione a coluna que cont√©m as decis√µes (INCLUDE/EXCLUDE/PENDING):</label>
                        <select id="decisionColumnSelect" class="w-full border rounded px-4 py-2" onchange="updateDecisionColumnMapping()">
                            <option value="">-- Selecione a coluna --</option>
                        </select>
                        <p class="text-xs text-purple-600 mt-2">
                            üí° O sistema tentar√° detectar automaticamente colunas como "STATUS", "DECISION", "DECIS√ÉO", etc.
                        </p>
                    </div>

                    <div class="mb-4">
                        <h3 class="font-semibold text-lg mb-2">Preview das Decis√µes:</h3>
                        <div class="bg-gray-50 p-4 rounded-lg max-h-96 overflow-y-auto">
                            <div class="table-container" style="overflow-x: auto;">
                                <table class="w-full text-xs border-collapse">
                                    <thead class="bg-gray-200 sticky top-0">
                                        <tr>
                                            <th class="border p-2 text-left">Study ID</th>
                                            <th class="border p-2 text-left">Title</th>
                                            <th class="border p-2 text-left">Decision</th>
                                            <th class="border p-2 text-left">Reason</th>
                                            <th class="border p-2">Match?</th>
                                        </tr>
                                    </thead>
                                    <tbody id="claudeResponseTableBody">
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>

                    <div class="mb-4 bg-yellow-50 p-4 rounded-lg">
                        <p class="text-sm text-yellow-800">
                            <strong>‚ö†Ô∏è Aten√ß√£o:</strong> Revise cuidadosamente antes de aplicar. 
                            Estudos n√£o encontrados (Match? = ‚ùå) ser√£o ignorados.
                        </p>
                    </div>

                    <div class="flex gap-3">
                        <button onclick="applyClaudeDecisions()" class="flex-1 bg-green-600 text-white px-6 py-3 rounded-lg hover:bg-green-700 transition font-semibold">
                            ‚úÖ Aplicar Decis√µes
                        </button>
                        <button onclick="closeClaudeResponseModal()" class="flex-1 bg-gray-500 text-white px-6 py-3 rounded-lg hover:bg-gray-600 transition font-semibold">
                            ‚ùå Cancelar
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <div id="projectsModal" class="modal">
            <div class="modal-content" style="max-width: 900px;">
                <span class="close" onclick="closeProjectsModal()">&times;</span>
                <h2 class="text-2xl font-bold mb-6">üìÅ Gerenciamento de Projetos</h2>
                
                <div class="mb-6 bg-blue-50 p-4 rounded-lg">
                    <p class="text-sm text-blue-800 mb-2">
                        <strong>üí° Dica:</strong> Todos os seus projetos s√£o salvos automaticamente no navegador. 
                        Voc√™ pode trabalhar em m√∫ltiplos projetos e alternar entre eles facilmente!
                    </p>
                </div>

                <div class="mb-6 flex gap-3">
                    <button onclick="createNewProject()" class="flex-1 bg-green-600 text-white px-6 py-3 rounded-lg hover:bg-green-700 transition font-semibold">
                        ‚ûï Criar Novo Projeto
                    </button>
                    <button onclick="triggerImportProject()" class="flex-1 bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700 transition font-semibold">
                        üì• Importar Projeto
                    </button>
                </div>
                <input type="file" id="importProjectInput" accept=".json" style="display: none;" onchange="importProjectFile(event)">

                <div class="mb-4">
                    <h3 class="font-semibold text-lg mb-3">Projetos Salvos:</h3>
                    <div id="projectsList" class="space-y-2 max-h-96 overflow-y-auto">
                    </div>
                </div>

                <div class="mt-6 pt-4 border-t">
                    <p class="text-xs text-gray-500">
                        <strong>Aten√ß√£o:</strong> Os projetos s√£o salvos localmente no seu navegador. 
                        Para backup externo, use "Exportar Projeto Completo" em cada projeto.
                    </p>
                </div>
            </div>
        </div>
    </div>

    <script>
        let studies = [];
        let currentView = 'screening'; // Default to screening mode
        let selectedStudies = new Set();
        let lastClickedStudyId = null;
        let keywords = {
            include: [],
            exclude: [],
            methods: ['introduction', 'method*', 'result*', 'conclusion*', 'background', 'discussion']
        };
        let showAbstracts = false; // Default to hidden abstracts for better performance
        let comparisonMode = false;
        let comparisonData = null;
        let reviewersData = [];
        let comparisonFilter = 'all';
        let selectedReviewersForExport = [];
        let newReviewerName = '';
        let showOtherReviewersDecisions = true;
        let newReviewerDecisions = {};
        let currentProject = null;
        let autoSaveEnabled = true;
        let autoSaveTimer = null;
        let currentSearchQuery = '';
        let searchFilteredStudies = [];

        // Deduplication variables
        let allFilesStudies = [];
        let fileContents = []; // Store raw file contents for calibration
        let doiDuplicates = [];
        let titleDuplicates = [];
        let duplicatesRemoved = {
            doi: 0,
            title: 0
        };
        let isSingleFileMode = false; // Track if we're processing a single file

        // Variables to remember Claude command modal range
        let rememberedRangeStart = null;
        let rememberedRangeEnd = null;
        let rememberedFilter = 'all';

        document.addEventListener('DOMContentLoaded', function() {
            setupDragAndDrop();
            document.getElementById('fileInput').addEventListener('change', handleFileSelect);
            updateRangeInfo();
            checkForSavedProjects();
            updateResultsCounter();
            restoreSearchMode();

            // Add listeners to range inputs to save values when they change
            const rangeStartInput = document.getElementById('rangeStart');
            const rangeEndInput = document.getElementById('rangeEnd');
            const claudeFilterInput = document.getElementById('claudeCommandFilter');

            if (rangeStartInput) {
                rangeStartInput.addEventListener('input', function() {
                    rememberedRangeStart = this.value || null;
                });
                rangeStartInput.addEventListener('change', function() {
                    rememberedRangeStart = this.value || null;
                });
            }

            if (rangeEndInput) {
                rangeEndInput.addEventListener('input', function() {
                    rememberedRangeEnd = this.value || null;
                });
                rangeEndInput.addEventListener('change', function() {
                    rememberedRangeEnd = this.value || null;
                });
            }

            if (claudeFilterInput) {
                claudeFilterInput.addEventListener('change', function() {
                    rememberedFilter = this.value || 'all';
                });
            }

            // Add listener to close modals when clicking outside
            window.addEventListener('click', function(event) {
                const claudeModal = document.getElementById('claudeCommandModal');
                if (event.target === claudeModal) {
                    // Save values before closing
                    if (rangeStartInput) rememberedRangeStart = rangeStartInput.value || null;
                    if (rangeEndInput) rememberedRangeEnd = rangeEndInput.value || null;
                    if (claudeFilterInput) rememberedFilter = claudeFilterInput.value || 'all';
                    claudeModal.style.display = 'none';
                }
            });
        });

        function restoreSearchMode() {
            const savedMode = localStorage.getItem('advancedSearchMode');
            const toggle = document.getElementById('advancedSearchToggle');
            const searchInput = document.getElementById('searchInput');
            const modeLabel = document.getElementById('searchModeLabel');

            // Default to advanced mode if not set
            const isAdvanced = savedMode === null ? true : savedMode === 'true';

            toggle.checked = isAdvanced;
            modeLabel.textContent = isAdvanced ? 'Busca Avan√ßada' : 'Busca Simples';

            if (isAdvanced) {
                searchInput.placeholder = 'üîç Busca avan√ßada: diabetes AND (treatment OR therapy) NOT "case report" author:Smith';
            } else {
                searchInput.placeholder = 'üîç Busca simples: digite palavras-chave (diabetes treatment insulin)';
            }
        }

        function setupDragAndDrop() {
            const dropArea = document.getElementById('uploadArea');
            
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropArea.addEventListener(eventName, preventDefaults, false);
            });

            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }

            ['dragenter', 'dragover'].forEach(eventName => {
                dropArea.addEventListener(eventName, () => {
                    dropArea.classList.add('drag-over');
                }, false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                dropArea.addEventListener(eventName, () => {
                    dropArea.classList.remove('drag-over');
                }, false);
            });

            dropArea.addEventListener('drop', handleDrop, false);
        }

        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;
            handleFiles(files);
        }

        function handleFileSelect(e) {
            const files = e.target.files;
            handleFiles(files);
        }

        async function handleFiles(files) {
            if (files.length > 0) {
                // Multiple files - use deduplication workflow
                if (files.length > 1) {
                    await processMultipleFiles(Array.from(files));
                } else {
                    // Single file - use new workflow with format detection
                    await processSingleFile(files[0]);
                }
            }
        }

        async function processSingleFile(file) {
            showLoading('Carregando arquivo...', 'Lendo e processando o arquivo...');

            isSingleFileMode = true; // Mark as single file mode
            allFilesStudies = [];
            fileContents = []; // Reset file contents

            const content = await readFileContent(file);
            const studies = parseFileContent(content, file.name);

            // Store raw content for calibration
            fileContents.push({
                filename: file.name,
                content: content
            });

            // Coletar estat√≠sticas
            const studiesWithYear = studies.filter(s => s.year && s.year.trim() !== '').length;
            const studiesWithoutYear = studies.length - studiesWithYear;

            const fileStats = [{
                filename: file.name,
                total: studies.length,
                withYear: studiesWithYear,
                withoutYear: studiesWithoutYear
            }];

            allFilesStudies = studies;

            await sleep(300);
            hideLoading();

            // Mostrar modal de confirma√ß√£o (sem op√ß√£o de deduplica√ß√£o)
            showSingleFileConfirmationModal(fileStats, allFilesStudies.length);
        }

        async function processMultipleFiles(files) {
            showLoading('Carregando arquivos...', 'Lendo e processando os arquivos...');

            isSingleFileMode = false; // Mark as multiple file mode
            allFilesStudies = [];
            fileContents = []; // Reset file contents
            const fileStats = [];  // Para armazenar estat√≠sticas de cada arquivo

            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                updateProgress((i / files.length) * 30);

                const content = await readFileContent(file);
                const studies = parseFileContent(content, file.name);

                // Store raw content for calibration
                fileContents.push({
                    filename: file.name,
                    content: content
                });

                // Coletar estat√≠sticas
                const studiesWithYear = studies.filter(s => s.year && s.year.trim() !== '').length;
                const studiesWithoutYear = studies.length - studiesWithYear;

                fileStats.push({
                    filename: file.name,
                    total: studies.length,
                    withYear: studiesWithYear,
                    withoutYear: studiesWithoutYear
                });

                allFilesStudies = allFilesStudies.concat(studies);
            }

            updateProgress(40);
            await sleep(300);

            hideLoading();

            // Mostrar modal de confirma√ß√£o
            showFilesConfirmationModal(fileStats, allFilesStudies.length);
        }

        function readFileContent(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = reject;
                reader.readAsText(file);
            });
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // File format parsers
        function parseFileContent(content, filename) {
            // Try to detect format
            if (filename.endsWith('.nbib') || content.includes('PMID-')) {
                return parseNBIB(content);
            } else if (filename.endsWith('.ciw') || content.includes('FN Clarivate')) {
                return parseCIW(content);
            } else if (detectPubMedAbstract(content)) {
                // PubMed Abstract format (texto com doi:, PMID:, etc.)
                return parsePubMedAbstract(content);
            } else {
                // Default to RIS format
                return parseRIS(content);
            }
        }

        // Detect PubMed Abstract format
        function detectPubMedAbstract(content) {
            const lines = content.split('\n').slice(0, 50); // Check first 50 lines
            let hasNumberedStart = false;
            let hasDOI = false;
            let hasPMID = false;

            for (const line of lines) {
                // Check for numbered article start (e.g., "1. ", "2. ")
                if (/^\d+\.\s+[A-Z]/.test(line.trim())) {
                    hasNumberedStart = true;
                }
                // Check for doi: format
                if (/^doi:\s+/i.test(line.trim())) {
                    hasDOI = true;
                }
                // Check for PMID: format
                if (/^PMID:\s+\d+/i.test(line.trim())) {
                    hasPMID = true;
                }
            }

            // If has numbered starts and at least one of DOI/PMID, it's PubMed Abstract
            return hasNumberedStart && (hasDOI || hasPMID);
        }

        // Parse PubMed Abstract format using EMPTY LINE boundaries
        function parsePubMedAbstract(content) {
            const studies = [];
            const lines = content.split('\n');

            for (let i = 0; i < lines.length; i++) {
                const trimmedLine = lines[i].trim();

                // Detect start of article: "1. Journal. 2025..."
                const articleStart = trimmedLine.match(/^(\d+)\.\s+(.+)/);
                if (!articleStart || !trimmedLine.match(/\b(19|20)\d{2}\b/)) continue;

                // Extract year and DOI from first line
                const journalLine = articleStart[2];
                const yearMatch = journalLine.match(/\b(19|20)\d{2}\b/);
                const doiMatch = journalLine.match(/doi:\s*(10\.\S+?)\.?\s*$/i);

                const study = {
                    id: '',
                    doi: doiMatch ? doiMatch[1] : '',
                    title: '',
                    authors: [],
                    year: yearMatch ? yearMatch[0] : '',
                    abstract: '',
                    journal: journalLine,
                    included: false,
                    excluded: false,
                    decision: 'pending'
                };

                i++; // Move past journal line

                // Find first empty line (marks end of journal section)
                while (i < lines.length && lines[i].trim()) i++;
                i++; // Skip the empty line

                // Collect TITLE (all lines until next empty line)
                let titleLines = [];
                while (i < lines.length && lines[i].trim()) {
                    titleLines.push(lines[i].trim());
                    i++;
                }
                study.title = titleLines.join(' ');
                i++; // Skip empty line after title

                // Collect AUTHORS (all lines until next empty line)
                let authorLines = [];
                while (i < lines.length && lines[i].trim()) {
                    authorLines.push(lines[i].trim());
                    i++;
                }
                // Parse authors from collected lines
                const authorText = authorLines.join(' ');
                if (authorText.match(/\(\d+\)/)) {
                    const authorParts = authorText.replace(/\(\d+\)/g, '').replace(/\(#\)/g, '').split(',');
                    authorParts.forEach(author => {
                        const clean = author.trim().replace(/\.$/, '');
                        if (clean && clean.length > 2) {
                            study.authors.push(clean);
                        }
                    });
                }
                i++; // Skip empty line after authors

                // Skip "Author information:" section (all lines until empty line)
                if (i < lines.length && lines[i].trim().match(/^Author information:/i)) {
                    while (i < lines.length && lines[i].trim()) i++;
                    i++; // Skip empty line
                }

                // Collect ABSTRACT (all lines until empty line or DOI/PMID)
                let abstractLines = [];
                while (i < lines.length) {
                    const line = lines[i].trim();

                    // Stop at DOI/PMID/PMCID/Copyright
                    if (line.match(/^(DOI:|PMID:|PMCID:|Copyright|¬©|Conflict of interest)/i)) {
                        break;
                    }

                    // Stop at empty line
                    if (!line) break;

                    // Skip "Erratum for" and "Figure" lines
                    if (line.match(/^(Erratum for|Figure \[)/i)) {
                        i++;
                        continue;
                    }

                    abstractLines.push(line);
                    i++;
                }
                study.abstract = abstractLines.join(' ');

                // Extract DOI, PMID, PMCID from remaining lines
                while (i < lines.length) {
                    const line = lines[i].trim();

                    if (line.match(/^DOI:\s+/i)) {
                        const m = line.match(/^DOI:\s*(10\.\S+)/i);
                        if (m && !study.doi) study.doi = m[1];
                    } else if (line.match(/^PMID:\s+\d+/i)) {
                        const m = line.match(/^PMID:\s*(\d+)/i);
                        if (m) study.id = m[1];
                    } else if (line.match(/^PMCID:\s+/i)) {
                        const m = line.match(/^PMCID:\s*(.+)/i);
                        if (m && !study.doi) study.doi = 'PMCID:' + m[1].trim();
                    }

                    // Stop at next article or end
                    if (line.match(/^\d+\.\s+.+\b(19|20)\d{2}\b/)) {
                        i--; // Back up so outer loop catches it
                        break;
                    }

                    i++;
                }

                studies.push(study);
            }

            return studies;
        }

        function parseRIS(content) {
            const studies = [];
            const lines = content.split('\n');
            let currentStudy = null;
            let currentField = '';
            let authors = [];

            // Get custom parser rules if available
            const rules = customParserRules['ris'] || {};

            // Build regex patterns from custom rules or use defaults
            const titleTags = rules.title || ['TI', 'T1', 'ST'];
            const authorTags = rules.author || ['AU', 'A1', 'FAU'];
            const yearTags = rules.year || ['PY', 'Y1', 'DA'];
            const doiTags = rules.doi || ['DO', 'L2']; // DO (padr√£o), L2 (Embase). M3 tratado separadamente
            const abstractTags = rules.abstract || ['AB', 'N2'];

            const titlePattern = new RegExp(`^(${titleTags.join('|')})\\s+-`);
            const authorPattern = new RegExp(`^(${authorTags.join('|')})\\s+-`);
            const yearPattern = new RegExp(`^(${yearTags.join('|')})\\s+-`);
            const doiPattern = new RegExp(`^(${doiTags.join('|')})\\s+-`);
            const abstractPattern = new RegExp(`^(${abstractTags.join('|')})\\s+-`);

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const trimmedLine = line.trim();

                // Detecta in√≠cio de registro (TY com varia√ß√µes de espa√ßamento)
                if (trimmedLine.match(/^TY\s+-/)) {
                    if (currentStudy && currentStudy.title) {
                        currentStudy.authors = authors.slice();
                        studies.push({...currentStudy});
                    }
                    currentStudy = {
                        id: '',
                        doi: '',
                        title: '',
                        authors: [],
                        year: '',
                        abstract: '',
                        pdfFound: false,
                        included: false,
                        excluded: false,
                        reasonExclusion: '',
                        observations: ''
                    };
                    authors = [];
                // T√≠tulo (usa padr√£o customizado ou padr√£o)
                } else if (trimmedLine.match(titlePattern)) {
                    if (currentStudy) {
                        const value = trimmedLine.replace(titlePattern, '').trim();
                        currentStudy.title = value;
                        currentField = 'title';
                    }
                // Autores (usa padr√£o customizado ou padr√£o)
                } else if (trimmedLine.match(authorPattern)) {
                    const value = trimmedLine.replace(authorPattern, '').trim();
                    if (value) authors.push(value);
                    currentField = 'author';
                // Ano (usa padr√£o customizado ou padr√£o)
                } else if (trimmedLine.match(yearPattern)) {
                    if (currentStudy) {
                        const value = trimmedLine.replace(yearPattern, '').trim();
                        // Extrai apenas o ano (4 d√≠gitos)
                        const yearMatch = value.match(/\d{4}/);
                        if (yearMatch) currentStudy.year = yearMatch[0];
                        currentField = 'year';
                    }
                // Abstract (usa padr√£o customizado ou padr√£o)
                } else if (trimmedLine.match(abstractPattern)) {
                    if (currentStudy) {
                        const value = trimmedLine.replace(abstractPattern, '').trim();
                        currentStudy.abstract = value;
                        currentField = 'abstract';
                    }
                // DOI (usa padr√£o customizado ou padr√£o)
                } else if (trimmedLine.match(doiPattern)) {
                    if (currentStudy) {
                        const value = trimmedLine.replace(doiPattern, '').trim();
                        // Remove "doi:" prefix se houver
                        const cleanDoi = value.replace(/^doi:/i, '').trim();
                        // Validate that this is actually a DOI (must start with 10. and contain /)
                        // Ignore document types like "review", "editorial", etc.
                        if (cleanDoi && cleanDoi.match(/^10\.\d{4,}/)) {
                            currentStudy.doi = cleanDoi;
                        }
                        currentField = 'doi';
                    }
                // ID
                } else if (trimmedLine.match(/^ID\s+-/)) {
                    if (currentStudy) {
                        const value = trimmedLine.replace(/^ID\s+-\s*/, '').trim();
                        currentStudy.id = value;
                        currentField = 'id';
                    }
                // Fim de registro
                } else if (trimmedLine.match(/^ER\s+-/)) {
                    if (currentStudy && currentStudy.title) {
                        currentStudy.authors = authors.slice();
                        studies.push({...currentStudy});
                    }
                    currentStudy = null;
                    authors = [];
                    currentField = '';
                // Continua√ß√£o de campo multi-linha
                } else if (trimmedLine.length > 0 && !trimmedLine.match(/^[A-Z0-9]{1,4}\s+-/) && currentField && currentStudy) {
                    if (currentField === 'title') {
                        currentStudy.title += ' ' + trimmedLine;
                    } else if (currentField === 'abstract') {
                        currentStudy.abstract += ' ' + trimmedLine;
                    }
                }
            }

            // Adiciona √∫ltimo registro se houver
            if (currentStudy && currentStudy.title) {
                currentStudy.authors = authors.slice();
                studies.push({...currentStudy});
            }

            return studies;
        }

        function parseNBIB(content) {
            const studies = [];
            const lines = content.split('\n');
            let currentStudy = null;
            let currentField = '';
            let authors = [];

            // Get custom parser rules if available
            const rules = customParserRules['nbib'] || {};

            // Build regex patterns from custom rules or use defaults
            const titleTags = rules.title || ['TI'];
            const authorTags = rules.author || ['AU', 'FAU'];
            const yearTags = rules.year || ['DP'];
            const doiTags = rules.doi || ['LID', 'AID'];
            const abstractTags = rules.abstract || ['AB'];

            const titlePattern = new RegExp(`^(${titleTags.join('|')})\\s+-`);
            const authorPattern = new RegExp(`^(${authorTags.join('|')})\\s+-`);
            const yearPattern = new RegExp(`^(${yearTags.join('|')})\\s+-`);
            const abstractPattern = new RegExp(`^(${abstractTags.join('|')})\\s+-`);

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const trimmedLine = line.trim();

                if (trimmedLine.startsWith('PMID-')) {
                    if (currentStudy && currentStudy.title) {
                        currentStudy.authors = authors.slice();
                        studies.push({...currentStudy});
                    }
                    currentStudy = {
                        id: trimmedLine.substring(5).trim(),
                        doi: '',
                        title: '',
                        authors: [],
                        year: '',
                        abstract: '',
                        pdfFound: false,
                        included: false,
                        excluded: false,
                        reasonExclusion: '',
                        observations: ''
                    };
                    authors = [];
                    currentField = '';
                } else if (trimmedLine.match(titlePattern)) {
                    if (currentStudy) {
                        const value = trimmedLine.replace(titlePattern, '').trim();
                        currentStudy.title = value;
                        currentField = 'title';
                    }
                } else if (trimmedLine.match(authorPattern)) {
                    const value = trimmedLine.replace(authorPattern, '').trim();
                    if (value) authors.push(value);
                    currentField = 'author';
                } else if (trimmedLine.match(yearPattern)) {
                    if (currentStudy) {
                        const value = trimmedLine.replace(yearPattern, '').trim();
                        const yearMatch = value.match(/\d{4}/);
                        if (yearMatch) currentStudy.year = yearMatch[0];
                        currentField = 'year';
                    }
                } else if (trimmedLine.match(abstractPattern)) {
                    if (currentStudy) {
                        const value = trimmedLine.replace(abstractPattern, '').trim();
                        currentStudy.abstract = value;
                        currentField = 'abstract';
                    }
                } else if ((trimmedLine.startsWith('LID -') || trimmedLine.startsWith('AID -')) && trimmedLine.includes('[doi]')) {
                    if (currentStudy && !currentStudy.doi) { // Only set if not already set
                        // Extract DOI, removing [doi] suffix
                        const doiMatch = trimmedLine.match(/10\.\d{4,}[^\s\[]+/);
                        if (doiMatch) {
                            currentStudy.doi = doiMatch[0];
                        }
                    }
                } else if (trimmedLine.length > 0 && line.startsWith('      ') && currentField && currentStudy) {
                    // NBIB continuation lines start with 6 spaces (but NOT a tag)
                    const continuation = trimmedLine;
                    if (currentField === 'title') {
                        currentStudy.title += ' ' + continuation;
                    } else if (currentField === 'abstract') {
                        currentStudy.abstract += ' ' + continuation;
                    }
                } else if (trimmedLine === '' || trimmedLine.match(/^[A-Z]{2,4}\s*-/)) {
                    // Empty line or new tag = reset field but don't save yet
                    if (trimmedLine.match(/^[A-Z]{2,4}\s*-/)) {
                        currentField = '';
                    }
                }
            }

            // Save last study
            if (currentStudy && currentStudy.title) {
                currentStudy.authors = authors.slice();
                studies.push({...currentStudy});
            }

            return studies;
        }

        function parseCIW(content) {
            const studies = [];
            const lines = content.split('\n');
            let currentStudy = null;
            let currentField = '';
            let authors = [];

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];

                if (line.startsWith('PT ')) {
                    if (currentStudy && currentStudy.title) {
                        currentStudy.authors = authors.slice();
                        studies.push({...currentStudy});
                    }
                    currentStudy = {
                        id: '',
                        doi: '',
                        title: '',
                        authors: [],
                        year: '',
                        abstract: '',
                        pdfFound: false,
                        included: false,
                        excluded: false,
                        reasonExclusion: '',
                        observations: ''
                    };
                    authors = [];
                } else if (line.startsWith('TI ')) {
                    if (currentStudy) {
                        currentStudy.title = line.substring(3).trim();
                        currentField = 'title';
                    }
                } else if (line.startsWith('AU ') || line.startsWith('AF ')) {
                    const author = line.substring(3).trim();
                    if (author) authors.push(author);
                    currentField = 'author';
                } else if (line.startsWith('PY ')) {
                    if (currentStudy) {
                        currentStudy.year = line.substring(3).trim();
                        currentField = 'year';
                    }
                } else if (line.startsWith('AB ')) {
                    if (currentStudy) {
                        currentStudy.abstract = line.substring(3).trim();
                        currentField = 'abstract';
                    }
                } else if (line.startsWith('DI ')) {
                    if (currentStudy) {
                        currentStudy.doi = line.substring(3).trim();
                        currentField = 'doi';
                    }
                } else if (line.startsWith('ER')) {
                    if (currentStudy && currentStudy.title) {
                        currentStudy.authors = authors.slice();
                        studies.push({...currentStudy});
                    }
                    currentStudy = null;
                    authors = [];
                    currentField = '';
                } else if (line.startsWith('   ') && currentField && currentStudy) {
                    const continuation = line.trim();
                    if (currentField === 'title') {
                        currentStudy.title += ' ' + continuation;
                    } else if (currentField === 'abstract') {
                        currentStudy.abstract += ' ' + continuation;
                    } else if (currentField === 'author') {
                        authors.push(continuation);
                    }
                }
            }

            if (currentStudy && currentStudy.title) {
                currentStudy.authors = authors.slice();
                studies.push({...currentStudy});
            }

            return studies;
        }

        // Normalization functions
        function normalizeDOI(doi) {
            if (!doi) return '';
            return doi.trim()
                .toLowerCase()
                .replace(/^https?:\/\/(dx\.)?doi\.org\//i, '')
                .replace(/^doi:\s*/i, '');
        }

        function normalizeTitle(title) {
            if (!title) return '';
            return title
                .toLowerCase()
                .replace(/[^a-z\s]/g, '')
                .replace(/\s+/g, ' ')
                .trim();
        }

        // Find duplicates
        function findDuplicatesByDOI(studies) {
            const doiMap = new Map();
            const duplicates = [];

            studies.forEach((study, index) => {
                const normalizedDoi = normalizeDOI(study.doi);
                if (normalizedDoi) {
                    if (!doiMap.has(normalizedDoi)) {
                        doiMap.set(normalizedDoi, []);
                    }
                    doiMap.get(normalizedDoi).push({...study, originalIndex: index});
                }
            });

            doiMap.forEach((group, doi) => {
                if (group.length > 1) {
                    duplicates.push({
                        doi: doi,
                        items: group
                    });
                }
            });

            return duplicates;
        }

        function findDuplicatesByTitle(studies) {
            const titleMap = new Map();
            const duplicates = [];

            studies.forEach((study, index) => {
                const normalizedTitle = normalizeTitle(study.title);
                if (normalizedTitle) {
                    if (!titleMap.has(normalizedTitle)) {
                        titleMap.set(normalizedTitle, []);
                    }
                    titleMap.get(normalizedTitle).push({...study, originalIndex: index});
                }
            });

            titleMap.forEach((group, title) => {
                if (group.length > 1) {
                    duplicates.push({
                        normalizedTitle: title,
                        items: group
                    });
                }
            });

            return duplicates;
        }

        // UI Functions for loading
        function showLoading(title, message) {
            document.getElementById('loadingOverlay').style.display = 'flex';
            document.getElementById('loadingTitle').textContent = title;
            document.getElementById('loadingMessage').textContent = message;
            updateProgress(0);
        }

        function hideLoading() {
            document.getElementById('loadingOverlay').style.display = 'none';
        }

        function updateProgress(percent) {
            document.getElementById('progressBar').style.width = percent + '%';
            document.getElementById('progressText').textContent = Math.round(percent) + '%';
        }

        function parseRISFile(content) {
            if (!currentProject) {
                const projectName = prompt('Digite o nome do projeto:', 'Revis√£o Sistem√°tica - ' + new Date().toLocaleDateString());
                if (!projectName) {
                    alert('√â necess√°rio dar um nome ao projeto!');
                    return;
                }

                const projectId = generateProjectId();
                currentProject = {
                    id: projectId,
                    name: projectName,
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString(),
                    studies: [],
                    keywords: keywords
                };
            }

            studies = [];
            const lines = content.split('\n');
            let currentStudy = {};
            let currentField = '';
            let authors = [];

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                if (line.startsWith('TY  -')) {
                    currentStudy = {
                        id: '',
                        doi: '',
                        title: '',
                        authors: [],
                        year: '',
                        abstract: '',
                        pdfFound: false,
                        included: false,
                        excluded: false,
                        reasonExclusion: '',
                        observations: ''
                    };
                    authors = [];
                } else if (line.startsWith('TI  -') || line.startsWith('ST  -')) {
                    currentStudy.title = line.substring(6).trim();
                    currentField = 'title';
                } else if (line.startsWith('AU  -')) {
                    authors.push(line.substring(6).trim());
                    currentField = 'author';
                } else if (line.startsWith('PY  -')) {
                    currentStudy.year = line.substring(6).trim();
                    currentField = 'year';
                } else if (line.startsWith('AB  -')) {
                    currentStudy.abstract = line.substring(6).trim();
                    currentField = 'abstract';
                } else if (line.startsWith('DO  -')) {
                    currentStudy.doi = line.substring(6).trim();
                    currentField = 'doi';
                } else if (line.startsWith('ID  -')) {
                    currentStudy.id = line.substring(6).trim();
                    currentField = 'id';
                } else if (line.startsWith('ER  -')) {
                    if (currentStudy.title) {
                        currentStudy.authors = authors.slice();
                        if (!currentStudy.id) {
                            currentStudy.id = studies.length + 1;
                        }
                        studies.push({...currentStudy});
                    }
                    currentStudy = {};
                    authors = [];
                    currentField = '';
                } else if (line.length > 0 && !line.includes('  -') && currentField) {
                    if (currentField === 'title') {
                        currentStudy.title += ' ' + line;
                    } else if (currentField === 'abstract') {
                        currentStudy.abstract += ' ' + line;
                    }
                }
            }

            if (studies.length > 0) {
                document.getElementById('uploadArea').classList.add('hidden');
                document.getElementById('mainApp').classList.remove('hidden');
                updateStats();
                renderSpreadsheet();
                renderScreeningList();
                updateRangeInfo();
                updateResultsCounter();

                const projects = getAllProjects();
                const existingIndex = projects.findIndex(p => p.id === currentProject.id);
                
                if (existingIndex >= 0) {
                    projects[existingIndex] = currentProject;
                } else {
                    projects.push(currentProject);
                }
                
                saveProjectsList(projects);
                document.getElementById('currentProjectName').textContent = currentProject.name;
                
                showToast('Projeto salvo com sucesso!', 'success');
            } else {
                alert('Nenhum estudo encontrado no arquivo. Verifique o formato.');
            }
        }

        function updateStats() {
            document.getElementById('totalStudies').textContent = studies.length;
            document.getElementById('includedCount').textContent = studies.filter(s => s.included).length;
            document.getElementById('excludedCount').textContent = studies.filter(s => s.excluded).length;
            document.getElementById('pendingCount').textContent = studies.filter(s => !s.included && !s.excluded).length;
        }

        function updateResultsCounter() {
            const filtered = getFilteredStudies();
            const count = filtered.length;
            
            const countSpan = document.getElementById('searchCount');
            if (countSpan) {
                countSpan.textContent = `${count} estudos encontrados`;
            }
            
            const countSpanScreening = document.getElementById('searchCountScreening');
            if (countSpanScreening) {
                countSpanScreening.textContent = `${count} estudos`;
            }
        }

        function switchTab(tab) {
            currentView = tab;
            document.getElementById('tabSpreadsheet').classList.remove('active');
            document.getElementById('tabScreening').classList.remove('active');
            document.getElementById('spreadsheetView').classList.add('hidden');
            document.getElementById('screeningView').classList.add('hidden');

            if (tab === 'spreadsheet') {
                document.getElementById('tabSpreadsheet').classList.add('active');
                document.getElementById('spreadsheetView').classList.remove('hidden');
            } else {
                document.getElementById('tabScreening').classList.add('active');
                document.getElementById('screeningView').classList.remove('hidden');
            }
        }

        function applyHighlight(text) {
            if (!text) return '';
            
            let highlightedText = text;
            
            keywords.include.forEach(keyword => {
                const pattern = keyword.replace('*', '\\w*');
                const regex = new RegExp(`(${pattern})`, 'gi');
                highlightedText = highlightedText.replace(regex, '<span class="highlight-include">$1</span>');
            });
            
            keywords.exclude.forEach(keyword => {
                const pattern = keyword.replace('*', '\\w*');
                const regex = new RegExp(`(${pattern})`, 'gi');
                highlightedText = highlightedText.replace(regex, '<span class="highlight-exclude">$1</span>');
            });
            
            keywords.methods.forEach(keyword => {
                const pattern = keyword.replace('*', '\\w*');
                const regex = new RegExp(`(${pattern})`, 'gi');
                highlightedText = highlightedText.replace(regex, '<span class="highlight-methods">$1</span>');
            });
            
            return highlightedText;
        }

        function showComparisonFiltersInMain() {
            showCompareModal();
        }

        function updateComparisonModeIndicator() {
            const indicator = document.getElementById('comparisonModeIndicator');
            if (indicator) {
                if (comparisonMode && reviewersData.length > 0) {
                    indicator.classList.remove('hidden');
                } else {
                    indicator.classList.add('hidden');
                }
            }
        }

        function renderSpreadsheet() {
            const tbody = document.getElementById('spreadsheetBody');
            tbody.innerHTML = '';

            // Update button text based on current state
            const btn = document.getElementById('toggleAbstractsBtn');
            if (btn) {
                btn.innerHTML = showAbstracts ? 'üëÅÔ∏è Ocultar Abstracts' : 'üëÅÔ∏è Mostrar Abstracts';
            }

            const filteredStudies = getFilteredStudies();

            filteredStudies.forEach((study, index) => {
                const row = document.createElement('tr');

                // Apply comparison styling if in comparison mode, otherwise apply decision colors
                let rowClass = '';
                if (comparisonMode && comparisonData) {
                    rowClass = getConsensusClass(study);
                } else {
                    // Apply decision-based colors
                    if (study.included) {
                        rowClass = 'row-included';
                    } else if (study.excluded) {
                        rowClass = 'row-excluded';
                    } else {
                        rowClass = 'row-pending';
                    }
                }
                row.className = rowClass;
                
                const authorText = study.authors && study.authors.length > 0 
                    ? study.authors[0] + (study.authors.length > 1 ? ' et al.' : '')
                    : '';
                const studyId = authorText && study.year 
                    ? `${authorText}, ${study.year}`
                    : study.id;

                // Add comparison info badge if in comparison mode
                let comparisonBadge = '';
                if (comparisonMode && comparisonData && showOtherReviewersDecisions) {
                    const consensusInfo = getConsensusInfo(study);
                    if (consensusInfo) {
                        if (consensusInfo.allIncluded) {
                            comparisonBadge = `<span class="text-xs bg-green-500 text-white px-2 py-1 rounded ml-2">‚úÖ ${consensusInfo.includeCount} Incluem</span>`;
                        } else if (consensusInfo.allExcluded) {
                            comparisonBadge = `<span class="text-xs bg-red-500 text-white px-2 py-1 rounded ml-2">‚ùå ${consensusInfo.excludeCount} Excluem</span>`;
                        } else if (consensusInfo.hasConflict) {
                            comparisonBadge = `<span class="text-xs bg-yellow-500 text-white px-2 py-1 rounded ml-2">‚ö† ${consensusInfo.includeCount}‚úì ${consensusInfo.excludeCount}‚úó ${consensusInfo.pendingCount}‚ö™</span>`;
                        } else if (consensusInfo.pendingCount > 0) {
                            comparisonBadge = `<span class="text-xs bg-gray-400 text-white px-2 py-1 rounded ml-2">‚ö™ ${consensusInfo.pendingCount} Pendentes</span>`;
                        }

                        // Adiciona detalhes dos revisores individuais
                        if (showOtherReviewersDecisions) {
                            const reviewerBadges = consensusInfo.decisions.map(d => {
                                let badgeClass = 'reviewer-pending';
                                let icon = '‚ö™';
                                if (d.included) {
                                    badgeClass = 'reviewer-include';
                                    icon = '‚úÖ';
                                } else if (d.excluded) {
                                    badgeClass = 'reviewer-exclude';
                                    icon = '‚ùå';
                                }
                                return `<span class="reviewer-decision-badge ${badgeClass}" title="${d.reviewer}">${icon} ${d.reviewer}</span>`;
                            }).join('');
                            comparisonBadge += `<div class="mt-1">${reviewerBadges}</div>`;
                        }
                    }
                }

                row.innerHTML = `
                    <td class="border p-2 row-number text-sm">${index + 1}</td>
                    <td class="border p-2 text-sm">${studyId}${comparisonBadge}</td>
                    <td class="border p-2 text-sm">
                        ${study.doi ? `<a href="https://doi.org/${study.doi}" target="_blank" class="text-blue-600 hover:underline">üîó ${study.doi}</a>` : '-'}
                    </td>
                    <td class="border p-2 text-sm font-semibold">${applyHighlight(study.title)}</td>
                    <td class="border p-2 text-sm">${study.authors.join(', ')}</td>
                    <td class="border p-2 text-sm">${study.year}</td>
                    <td class="border p-2 abstract-cell text-xs">
                        <div class="${showAbstracts ? '' : 'hidden'}" style="max-height: 150px; overflow-y: auto;">
                            ${applyHighlight(study.abstract || '-')}
                        </div>
                    </td>
                    <td class="border p-2 text-center">
                        <input type="checkbox" ${study.pdfFound ? 'checked' : ''} 
                            onchange="updateStudyField(${study.id}, 'pdfFound', this.checked)">
                    </td>
                    <td class="border p-2 text-center">
                        <input type="checkbox" ${study.included ? 'checked' : ''} 
                            onchange="updateDecision(${study.id}, 'included', this.checked)">
                    </td>
                    <td class="border p-2 text-center">
                        <input type="checkbox" ${study.excluded ? 'checked' : ''} 
                            onchange="updateDecision(${study.id}, 'excluded', this.checked)">
                    </td>
                    <td class="border p-2">
                        <input type="text" value="${study.reasonExclusion || ''}" 
                            onchange="updateStudyField(${study.id}, 'reasonExclusion', this.value)"
                            class="w-full border rounded px-2 py-1 text-xs">
                    </td>
                    <td class="border p-2">
                        <input type="text" value="${study.observations || ''}" 
                            onchange="updateStudyField(${study.id}, 'observations', this.value)"
                            class="w-full border rounded px-2 py-1 text-xs">
                    </td>
                `;
                tbody.appendChild(row);
            });

            updateComparisonModeIndicator();
        }

        function renderScreeningList() {
            const listDiv = document.getElementById('studyList');
            listDiv.innerHTML = '';

            const filteredStudies = getFilteredStudies();

            filteredStudies.forEach((study, index) => {
                const card = document.createElement('div');

                // Base card styling
                let cardClass = 'study-card p-4 border-2 rounded-lg cursor-pointer';

                // Apply comparison styling if in comparison mode, otherwise apply decision colors
                if (comparisonMode && comparisonData) {
                    const consensusClass = getConsensusClass(study);
                    if (consensusClass) {
                        cardClass += ` ${consensusClass}`;
                    }
                } else {
                    // Apply decision-based colors
                    if (study.included) {
                        cardClass += ' card-included';
                    } else if (study.excluded) {
                        cardClass += ' card-excluded';
                    } else {
                        cardClass += ' card-pending';
                    }
                }

                // Add selection styling
                if (selectedStudies.has(study.id)) {
                    cardClass += ' border-blue-500 ring-2 ring-blue-300';
                }

                card.className = cardClass;
                card.onclick = (event) => {
                    if (event.shiftKey && lastClickedStudyId !== null) {
                        // Shift+Click: Select range from last clicked to current
                        selectStudyRange(lastClickedStudyId, study.id);
                    } else {
                        // Normal click: Toggle single selection
                        toggleStudySelection(study.id);
                        lastClickedStudyId = study.id;
                    }
                };

                const badge = study.included ? 'badge-included' : (study.excluded ? 'badge-excluded' : 'badge-pending');
                const badgeText = study.included ? 'Inclu√≠do' : (study.excluded ? 'Exclu√≠do' : 'Pendente');

                // Add comparison badge if in comparison mode
                let comparisonInfo = '';
                if (comparisonMode && comparisonData && showOtherReviewersDecisions) {
                    const consensusInfo = getConsensusInfo(study);
                    if (consensusInfo) {
                        if (consensusInfo.allIncluded) {
                            comparisonInfo = `<span class="text-xs bg-green-500 text-white px-2 py-1 rounded mt-2 inline-block">‚úÖ ${consensusInfo.includeCount} Incluem</span>`;
                        } else if (consensusInfo.allExcluded) {
                            comparisonInfo = `<span class="text-xs bg-red-500 text-white px-2 py-1 rounded mt-2 inline-block">‚ùå ${consensusInfo.excludeCount} Excluem</span>`;
                        } else if (consensusInfo.hasConflict) {
                            comparisonInfo = `<span class="text-xs bg-yellow-500 text-white px-2 py-1 rounded mt-2 inline-block">‚ö† ${consensusInfo.includeCount}‚úì ${consensusInfo.excludeCount}‚úó ${consensusInfo.pendingCount}‚ö™</span>`;
                        } else if (consensusInfo.pendingCount > 0) {
                            comparisonInfo = `<span class="text-xs bg-gray-400 text-white px-2 py-1 rounded mt-2 inline-block">‚ö™ ${consensusInfo.pendingCount} Pendentes</span>`;
                        }

                        // Adiciona badges dos revisores individuais
                        const reviewerBadges = consensusInfo.decisions.map(d => {
                            let badgeClass = 'reviewer-pending';
                            let icon = '‚ö™';
                            if (d.included) {
                                badgeClass = 'reviewer-include';
                                icon = '‚úÖ';
                            } else if (d.excluded) {
                                badgeClass = 'reviewer-exclude';
                                icon = '‚ùå';
                            }
                            return `<span class="reviewer-decision-badge ${badgeClass}" title="${d.reviewer}">${icon} ${d.reviewer}</span>`;
                        }).join('');
                        comparisonInfo += `<div class="mt-2">${reviewerBadges}</div>`;
                    }
                }

                card.innerHTML = `
                    <div class="flex justify-between items-start mb-2">
                        <span class="text-xs font-mono text-gray-500">#${study.id}</span>
                        <span class="decision-badge ${badge}">${badgeText}</span>
                    </div>
                    <h3 class="font-semibold text-sm mb-1">${study.title.substring(0, 80)}...</h3>
                    <p class="text-xs text-gray-600">${study.authors[0] || ''} ${study.year}</p>
                    ${comparisonInfo}
                `;
                listDiv.appendChild(card);
            });
        }

        function toggleStudySelection(studyId) {
            if (selectedStudies.has(studyId)) {
                selectedStudies.delete(studyId);
            } else {
                selectedStudies.add(studyId);
            }
            renderScreeningList();
            renderStudyDetails();
        }

        function selectStudyRange(startId, endId) {
            // Get the filtered studies list (respecting current filters)
            const filteredStudies = studies.filter(study => {
                const decision = study.decision || 'pending';
                const searchTerm = document.getElementById('searchBox')?.value.toLowerCase() || '';

                // Apply decision filter
                const decisionFilter = document.querySelector('input[name="decisionFilter"]:checked')?.value || 'all';
                if (decisionFilter !== 'all' && decision !== decisionFilter) {
                    return false;
                }

                // Apply search filter
                if (searchTerm && !study.title.toLowerCase().includes(searchTerm)) {
                    return false;
                }

                return true;
            });

            // Find indices of start and end studies in the filtered list
            const startIndex = filteredStudies.findIndex(s => s.id === startId);
            const endIndex = filteredStudies.findIndex(s => s.id === endId);

            if (startIndex === -1 || endIndex === -1) {
                return; // One of the IDs not found
            }

            // Determine the range (handle both directions)
            const minIndex = Math.min(startIndex, endIndex);
            const maxIndex = Math.max(startIndex, endIndex);

            // Check if the clicked study is already selected
            // If it is, DESELECT the entire range; otherwise SELECT the entire range
            const shouldSelect = !selectedStudies.has(endId);

            // Apply selection/deselection to all studies in the range
            for (let i = minIndex; i <= maxIndex; i++) {
                if (shouldSelect) {
                    selectedStudies.add(filteredStudies[i].id);
                } else {
                    selectedStudies.delete(filteredStudies[i].id);
                }
            }

            renderScreeningList();
            renderStudyDetails();
        }

        function renderStudyDetails() {
            const detailsDiv = document.getElementById('studyDetails');
            
            if (selectedStudies.size === 0) {
                detailsDiv.innerHTML = '<p class="text-gray-500 text-center py-12">Selecione um ou mais estudos para revisar</p>';
                return;
            }

            detailsDiv.innerHTML = '';

            selectedStudies.forEach(studyId => {
                const study = studies.find(s => s.id == studyId);
                if (!study) return;

                const detailCard = document.createElement('div');
                detailCard.className = 'bg-white border rounded-lg p-6 mb-4 shadow';
                
                const authorText = study.authors && study.authors.length > 0 
                    ? study.authors[0] + (study.authors.length > 1 ? ' et al.' : '')
                    : '';

                detailCard.innerHTML = `
                    <div class="mb-4">
                        <span class="text-xs font-mono text-gray-500">Study #${study.id}</span>
                        <h2 class="text-xl font-bold mt-2">${applyHighlight(study.title)}</h2>
                        <p class="text-sm text-gray-600 mt-2">
                            ${study.authors.join(', ')} (${study.year})
                        </p>
                        ${study.doi ? `<a href="https://doi.org/${study.doi}" target="_blank" class="text-blue-600 hover:underline text-sm">üîó https://doi.org/${study.doi}</a>` : ''}
                    </div>

                    <div class="mb-4">
                        <h3 class="font-semibold mb-2">Abstract</h3>
                        <div class="bg-gray-50 p-4 rounded text-sm max-h-64 overflow-y-auto">
                            ${applyHighlight(study.abstract || 'Sem abstract dispon√≠vel')}
                        </div>
                    </div>

                    <div class="mb-4">
                        <label class="block font-semibold mb-2 text-sm">Motivo da Exclus√£o</label>
                        <input type="text" value="${study.reasonExclusion || ''}" 
                            onchange="updateStudyField(${study.id}, 'reasonExclusion', this.value); renderScreeningList();"
                            class="w-full border rounded px-3 py-2 text-sm"
                            placeholder="Digite o motivo caso exclua o estudo">
                    </div>

                    <div class="flex gap-3">
                        <button onclick="makeDecision(${study.id}, 'include')" 
                            class="flex-1 ${study.included ? 'bg-green-600' : 'bg-green-500 hover:bg-green-600'} text-white px-6 py-3 rounded-lg transition font-semibold">
                            ‚úì Incluir
                        </button>
                        <button onclick="makeDecision(${study.id}, 'exclude')" 
                            class="flex-1 ${study.excluded ? 'bg-red-600' : 'bg-red-500 hover:bg-red-600'} text-white px-6 py-3 rounded-lg transition font-semibold">
                            ‚úó Excluir
                        </button>
                    </div>
                `;
                
                detailsDiv.appendChild(detailCard);
            });
        }

        function makeDecision(studyId, decision) {
            const study = studies.find(s => s.id == studyId);
            if (!study) return;

            if (decision === 'include') {
                study.included = true;
                study.excluded = false;
            } else {
                study.included = false;
                study.excluded = true;
            }

            updateStats();
            renderScreeningList();
            renderStudyDetails();
            if (currentView === 'spreadsheet') {
                renderSpreadsheet();
            }
            autoSave();
        }

        function updateDecision(studyId, field, value) {
            const study = studies.find(s => s.id == studyId);
            if (!study) return;

            if (field === 'included' && value) {
                study.included = true;
                study.excluded = false;
            } else if (field === 'excluded' && value) {
                study.excluded = true;
                study.included = false;
            } else {
                study[field] = value;
            }

            updateStats();
            renderSpreadsheet();
            renderScreeningList();
            renderStudyDetails();
            autoSave();
        }

        function updateStudyField(studyId, field, value) {
            const study = studies.find(s => s.id == studyId);
            if (study) {
                study[field] = value;
                autoSave();
            }
        }

        function toggleAllAbstracts() {
            showAbstracts = !showAbstracts;

            // Update button text
            const btn = document.getElementById('toggleAbstractsBtn');
            if (btn) {
                btn.innerHTML = showAbstracts ? 'üëÅÔ∏è Ocultar Abstracts' : 'üëÅÔ∏è Mostrar Abstracts';
            }

            renderSpreadsheet();
        }

        function getFilteredStudies() {
            const filterSelect = currentView === 'spreadsheet'
                ? document.getElementById('filterSpreadsheet')
                : document.getElementById('filterScreening');

            if (!filterSelect) return studies;

            const filter = filterSelect.value;
            let filtered = studies;

            if (filter === 'included') {
                filtered = studies.filter(s => s.included);
            } else if (filter === 'excluded') {
                filtered = studies.filter(s => s.excluded);
            } else if (filter === 'pending') {
                filtered = studies.filter(s => !s.included && !s.excluded);
            }

            // Aplica filtros de compara√ß√£o se estiver em modo compara√ß√£o
            if (comparisonMode && comparisonData) {
                const compFilterSelect = currentView === 'spreadsheet'
                    ? document.getElementById('comparisonMainFilter')
                    : document.getElementById('comparisonScreeningFilter');

                if (compFilterSelect && compFilterSelect.value !== 'comp-all') {
                    const compFilter = compFilterSelect.value;
                    const compIds = new Set();

                    comparisonData.forEach(comp => {
                        let matches = false;
                        if (compFilter === 'comp-consensus-include' && comp.allIncluded) {
                            matches = true;
                        } else if (compFilter === 'comp-consensus-exclude' && comp.allExcluded) {
                            matches = true;
                        } else if (compFilter === 'comp-conflict' && comp.hasConflict) {
                            matches = true;
                        } else if (compFilter === 'comp-pending' && comp.pendingCount > 0) {
                            matches = true;
                        }

                        if (matches) {
                            compIds.add(comp.study.id);
                        }
                    });

                    filtered = filtered.filter(s => compIds.has(s.id));
                }
            }

            if (currentSearchQuery && searchFilteredStudies.length >= 0) {
                const searchIds = new Set(searchFilteredStudies.map(s => s.id));
                filtered = filtered.filter(s => searchIds.has(s.id));
            }

            return filtered;
        }

        function applyComparisonMainFilter() {
            applyFilters();
        }

        function applyFilters() {
            if (currentView === 'spreadsheet') {
                renderSpreadsheet();
            } else {
                renderScreeningList();
                selectedStudies.clear();
                renderStudyDetails();
            }
            updateResultsCounter();
        }

        function showKeywordsModal() {
            document.getElementById('includeKeywords').value = keywords.include.join(', ');
            document.getElementById('excludeKeywords').value = keywords.exclude.join(', ');
            document.getElementById('methodsKeywords').value = keywords.methods.join(', ');
            document.getElementById('keywordsModal').style.display = 'block';
        }

        function closeKeywordsModal() {
            document.getElementById('keywordsModal').style.display = 'none';
        }

        function applyKeywords() {
            keywords.include = document.getElementById('includeKeywords').value
                .split(',')
                .map(k => k.trim())
                .filter(k => k.length > 0);
            
            keywords.exclude = document.getElementById('excludeKeywords').value
                .split(',')
                .map(k => k.trim())
                .filter(k => k.length > 0);
            
            keywords.methods = document.getElementById('methodsKeywords').value
                .split(',')
                .map(k => k.trim())
                .filter(k => k.length > 0);

            closeKeywordsModal();
            renderSpreadsheet();
            renderStudyDetails();
            autoSave();
        }

        function exportDecisions() {
            if (!currentProject) {
                alert('Nenhum projeto ativo para exportar!');
                return;
            }

            const exportData = {
                projectName: currentProject.name,
                projectId: currentProject.id,
                createdAt: currentProject.createdAt,
                updatedAt: new Date().toISOString(),
                exportedAt: new Date().toISOString(),
                version: '2.0',
                keywords: keywords,
                studies: studies.map(s => ({
                    id: s.id,
                    doi: s.doi,
                    title: s.title,
                    authors: s.authors,
                    year: s.year,
                    abstract: s.abstract,
                    included: s.included,
                    excluded: s.excluded,
                    reasonExclusion: s.reasonExclusion,
                    observations: s.observations,
                    pdfFound: s.pdfFound
                })),
                stats: {
                    total: studies.length,
                    included: studies.filter(s => s.included).length,
                    excluded: studies.filter(s => s.excluded).length,
                    pending: studies.filter(s => !s.included && !s.excluded).length
                }
            };

            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${currentProject.name.replace(/[^a-z0-9]/gi, '_')}_COMPLETO_${Date.now()}.json`;
            link.click();
            
            showToast('Projeto completo exportado com sucesso!', 'success');
        }

        function exportAsRIS() {
            if (!currentProject) {
                alert('Nenhum projeto ativo para exportar!');
                return;
            }

            if (!studies || studies.length === 0) {
                alert('Nenhum estudo para exportar!');
                return;
            }

            // Generate RIS format
            let risContent = '';

            studies.forEach(study => {
                // Type of reference (always JOUR for journal article)
                risContent += 'TY  - JOUR\n';

                // Title
                if (study.title) {
                    risContent += `TI  - ${study.title}\n`;
                }

                // Authors
                if (study.authors && study.authors.length > 0) {
                    study.authors.forEach(author => {
                        risContent += `AU  - ${author}\n`;
                    });
                }

                // Year
                if (study.year) {
                    risContent += `PY  - ${study.year}\n`;
                }

                // DOI
                if (study.doi) {
                    risContent += `DO  - ${study.doi}\n`;
                }

                // Abstract
                if (study.abstract) {
                    risContent += `AB  - ${study.abstract}\n`;
                }

                // Custom fields for screening decisions
                if (study.included) {
                    risContent += `N1  - INCLUDED\n`;
                } else if (study.excluded) {
                    risContent += `N1  - EXCLUDED: ${study.reasonExclusion || 'No reason provided'}\n`;
                }

                // Observations
                if (study.observations) {
                    risContent += `N2  - ${study.observations}\n`;
                }

                // ID
                if (study.id) {
                    risContent += `ID  - ${study.id}\n`;
                }

                // End of record
                risContent += 'ER  - \n\n';
            });

            // Create download
            const blob = new Blob([risContent], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;

            const projectName = currentProject.name.replace(/[^a-z0-9]/gi, '_');
            const timestamp = new Date().toISOString().split('T')[0];
            a.download = `${projectName}_${timestamp}.ris`;

            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showToast(`${studies.length} estudos exportados em formato RIS!`, 'success');
        }

        function importDecisions() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json,.xlsx';
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (!file) return;

                if (file.name.endsWith('.json')) {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        try {
                            const data = JSON.parse(event.target.result);
                            
                            if (data.version && data.version === '2.0' && data.projectName) {
                                importCompleteProject(data);
                            } else {
                                applyImportedDecisions(data.studies || data);
                                showToast('Decis√µes importadas com sucesso!', 'success');
                            }
                        } catch (error) {
                            alert('Erro ao importar arquivo JSON: ' + error.message);
                        }
                    };
                    reader.readAsText(file);
                } else if (file.name.endsWith('.xlsx')) {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        try {
                            const data = new Uint8Array(event.target.result);
                            const workbook = XLSX.read(data, { type: 'array' });
                            const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                            const jsonData = XLSX.utils.sheet_to_json(firstSheet);
                            
                            const decisions = jsonData.map(row => ({
                                id: row['STUDY ID'] || row['ID'],
                                included: row['INCLUDED'] === 'TRUE' || row['INCLUDED'] === true,
                                excluded: row['EXCLUDED'] === 'TRUE' || row['EXCLUDED'] === true,
                                reasonExclusion: row['REASON FOR EXCLUSION'] || '',
                                observations: row['OBSERVATIONS'] || '',
                                pdfFound: row['PDF FOUND?'] === 'TRUE' || row['PDF FOUND?'] === true
                            }));
                            
                            applyImportedDecisions(decisions);
                            showToast('Decis√µes importadas da planilha com sucesso!', 'success');
                        } catch (error) {
                            alert('Erro ao importar planilha: ' + error.message);
                        }
                    };
                    reader.readAsArrayBuffer(file);
                }
            };
            input.click();
        }

        function importCompleteProject(data) {
            const projectId = generateProjectId();
            
            const importedProject = {
                id: projectId,
                name: data.projectName + ' (Importado)',
                createdAt: data.createdAt || new Date().toISOString(),
                updatedAt: new Date().toISOString(),
                studies: data.studies,
                keywords: data.keywords || keywords
            };

            const projects = getAllProjects();
            projects.push(importedProject);
            saveProjectsList(projects);

            currentProject = importedProject;
            studies = data.studies;
            keywords = data.keywords || keywords;

            document.getElementById('currentProjectName').textContent = importedProject.name;
            document.getElementById('uploadArea').classList.add('hidden');
            document.getElementById('mainApp').classList.remove('hidden');
            
            updateStats();
            renderSpreadsheet();
            renderScreeningList();
            updateRangeInfo();
            updateResultsCounter();
            
            showToast(`Projeto "${importedProject.name}" importado completamente!`, 'success');
        }

        // Fun√ß√£o para adicionar mais arquivos RIS ao projeto atual
        async function importAdditionalRIS() {
            if (!currentProject || studies.length === 0) {
                alert('Voc√™ precisa ter um projeto ativo antes de adicionar mais arquivos RIS!');
                return;
            }

            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.txt,.ris,.nbib,.ciw';
            input.multiple = true;

            input.onchange = async function(e) {
                const files = e.target.files;
                if (!files || files.length === 0) return;

                try {
                    await processAdditionalFiles(Array.from(files));
                } catch (error) {
                    hideLoading();
                    alert('Erro ao importar arquivos RIS adicionais: ' + error.message);
                    console.error(error);
                }
            };

            input.click();
        }

        // Process additional files with deduplication workflow
        async function processAdditionalFiles(files) {
            showLoading('Carregando novos arquivos...', 'Lendo e processando os arquivos...');

            const newStudiesArray = [];
            const fileStats = [];

            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                updateProgress((i / files.length) * 30);

                const content = await readFileContent(file);
                const parsedStudies = parseFileContent(content, file.name);

                // Coletar estat√≠sticas
                const studiesWithYear = parsedStudies.filter(s => s.year && s.year.trim() !== '').length;
                const studiesWithoutYear = parsedStudies.length - studiesWithYear;

                fileStats.push({
                    filename: file.name,
                    total: parsedStudies.length,
                    withYear: studiesWithYear,
                    withoutYear: studiesWithoutYear
                });

                newStudiesArray.push(...parsedStudies);
            }

            updateProgress(40);
            await sleep(300);

            // Combine existing studies with new studies for deduplication
            const combinedStudies = [...studies, ...newStudiesArray];

            // Store in allFilesStudies for deduplication process
            allFilesStudies = combinedStudies;

            hideLoading();

            // Show confirmation modal with file stats
            showAdditionalFilesConfirmationModal(fileStats, newStudiesArray.length);
        }

        function showAdditionalFilesConfirmationModal(fileStats, newArticlesCount) {
            document.getElementById('totalArticlesLoaded').textContent = newArticlesCount;
            document.getElementById('totalFilesLoaded').textContent = fileStats.length;

            const listDiv = document.getElementById('filesListConfirmation');
            listDiv.innerHTML = '';

            fileStats.forEach((stat, index) => {
                const fileDiv = document.createElement('div');
                fileDiv.className = 'bg-gray-50 rounded-lg p-4 border border-gray-200';

                fileDiv.innerHTML = `
                    <div class="flex justify-between items-center">
                        <div class="flex-1">
                            <p class="font-semibold text-sm text-gray-800">${stat.filename}</p>
                            <p class="text-xs text-gray-600 mt-1">
                                <span class="inline-block bg-blue-100 text-blue-800 px-2 py-0.5 rounded">
                                    ${stat.total} artigos
                                </span>
                                ${stat.withYear > 0 ? `
                                <span class="inline-block bg-green-100 text-green-800 px-2 py-0.5 rounded ml-1">
                                    ${stat.withYear} com ano
                                </span>
                                ` : ''}
                                ${stat.withoutYear > 0 ? `
                                <span class="inline-block bg-yellow-100 text-yellow-800 px-2 py-0.5 rounded ml-1">
                                    ${stat.withoutYear} sem ano
                                </span>
                                ` : ''}
                            </p>
                        </div>
                    </div>
                `;

                listDiv.appendChild(fileDiv);
            });

            const totalNoYear = fileStats.reduce((sum, f) => sum + f.withoutYear, 0);
            if (totalNoYear > 0) {
                document.getElementById('noYearWarning').classList.remove('hidden');
            } else {
                document.getElementById('noYearWarning').classList.add('hidden');
            }

            // Update button text for additional files mode
            document.getElementById('confirmFilesButton').innerHTML = '‚úÖ Confirmar e Prosseguir para Deduplica√ß√£o';

            // Mark that we're in additional files mode
            window.isAddingAdditionalFiles = true;

            document.getElementById('filesConfirmationModal').style.display = 'block';
        }

        async function proceedFromAdditionalFiles() {
            closeFilesConfirmationModal();

            showLoading('Analisando duplicados...', `${allFilesStudies.length} artigos totais (existentes + novos). Procurando duplicados por DOI...`);
            updateProgress(50);
            await sleep(500);

            doiDuplicates = findDuplicatesByDOI(allFilesStudies);

            updateProgress(100);
            await sleep(300);

            hideLoading();

            if (doiDuplicates.length > 0) {
                showDoiDeduplicationModal();
            } else {
                proceedToTitleDeduplication();
            }
        }

        function applyImportedDecisions(importedStudies) {
            importedStudies.forEach(imported => {
                const study = studies.find(s => s.id == imported.id || s.title === imported.title);
                if (study) {
                    study.included = imported.included || false;
                    study.excluded = imported.excluded || false;
                    study.reasonExclusion = imported.reasonExclusion || '';
                    study.observations = imported.observations || '';
                    study.pdfFound = imported.pdfFound || false;
                }
            });
            
            updateStats();
            renderSpreadsheet();
            renderScreeningList();
            renderStudyDetails();
            autoSave();
        }

        function exportSpreadsheet() {
            const data = studies.map(s => {
                const authorText = s.authors && s.authors.length > 0 
                    ? s.authors[0] + (s.authors.length > 1 ? ' et al.' : '')
                    : '';
                const studyId = authorText && s.year 
                    ? `${authorText}, ${s.year}`
                    : s.id;

                return {
                    'STUDY ID': studyId,
                    'DOI LINK': s.doi ? `https://doi.org/${s.doi}` : '',
                    'TITLE': s.title,
                    'AUTHOR': s.authors.join(', '),
                    'YEAR': s.year,
                    'ABSTRACT': s.abstract,
                    'PDF FOUND?': s.pdfFound ? 'TRUE' : 'FALSE',
                    'INCLUDED': s.included ? 'TRUE' : 'FALSE',
                    'EXCLUDED': s.excluded ? 'TRUE' : 'FALSE',
                    'REASON FOR EXCLUSION': s.reasonExclusion,
                    'OBSERVATIONS': s.observations
                };
            });

            const ws = XLSX.utils.json_to_sheet(data);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, 'Studies');
            XLSX.writeFile(wb, `systematic_review_${Date.now()}.xlsx`);
        }

        function copyTableToClipboard() {
            // Prepare data in the same format as exportSpreadsheet
            const data = studies.map(s => {
                const authorText = s.authors && s.authors.length > 0
                    ? s.authors[0] + (s.authors.length > 1 ? ' et al.' : '')
                    : '';
                const studyId = authorText && s.year
                    ? `${authorText}, ${s.year}`
                    : s.id;

                return {
                    'STUDY ID': studyId,
                    'DOI LINK': s.doi ? `https://doi.org/${s.doi}` : '',
                    'TITLE': s.title,
                    'AUTHOR': s.authors.join(', '),
                    'YEAR': s.year,
                    'ABSTRACT': s.abstract || '',
                    'PDF FOUND?': s.pdfFound ? 'TRUE' : 'FALSE',
                    'INCLUDED': s.included ? 'TRUE' : 'FALSE',
                    'EXCLUDED': s.excluded ? 'TRUE' : 'FALSE',
                    'REASON FOR EXCLUSION': s.reasonExclusion || '',
                    'OBSERVATIONS': s.observations || ''
                };
            });

            if (data.length === 0) {
                showToast('‚ö†Ô∏è Nenhum estudo para copiar!', 'warning');
                return;
            }

            // Convert to TSV format (Tab-Separated Values)
            // IMPORTANTE: Usar \r\n (CRLF) como Excel, n√£o apenas \n (LF)
            const headers = Object.keys(data[0]);
            const tsvContent = [
                headers.join('\t'), // Header row
                ...data.map(row => headers.map(header => {
                    const value = row[header] || '';
                    // Replace tabs and newlines to prevent breaking the TSV structure
                    return String(value).replace(/\t/g, ' ').replace(/[\r\n]+/g, ' ');
                }).join('\t'))
            ].join('\r\n'); // CRLF (Windows format) - mesmo formato que Excel usa

            // Copy to clipboard as plain text TSV
            navigator.clipboard.writeText(tsvContent)
                .then(() => {
                    showToast(`‚úÖ ${studies.length} estudos copiados em formato TSV! Cole no Excel ou Google Planilhas.`, 'success');
                })
                .catch(err => {
                    console.error('Erro ao copiar:', err);
                    showToast('‚ùå Erro ao copiar para √°rea de transfer√™ncia. Verifique as permiss√µes do navegador.', 'error');
                });
        }

        function showCompareModal() {
            document.getElementById('compareModal').style.display = 'block';
        }

        function closeCompareModal() {
            document.getElementById('compareModal').style.display = 'none';
        }

        function compareReviewers() {
            const filesInput = document.getElementById('compareFiles');
            const files = filesInput.files;
            const nameInput = document.getElementById('newReviewerNameInput').value.trim();

            if (files.length < 2) {
                alert('Selecione pelo menos 2 arquivos para comparar');
                return;
            }

            // Captura o nome do novo revisor (opcional, mas recomendado)
            if (nameInput) {
                newReviewerName = nameInput;
            } else {
                newReviewerName = 'Novo Revisor';
            }

            const promises = Array.from(files).map(file => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        try {
                            const data = JSON.parse(e.target.result);
                            resolve({
                                reviewer: data.reviewer || data.projectName || file.name.replace('.json', ''),
                                studies: data.studies
                            });
                        } catch (error) {
                            reject(error);
                        }
                    };
                    reader.readAsText(file);
                });
            });

            Promise.all(promises).then(data => {
                reviewersData = data;

                // Mescla os studies de todos os revisores e prepara para triagem
                const allStudyIds = new Set();
                data.forEach(reviewer => {
                    reviewer.studies.forEach(study => allStudyIds.add(study.id));
                });

                // Usa os studies do primeiro revisor como base, mas reseta as decis√µes
                studies = data[0].studies.map(study => {
                    // Cria uma c√≥pia limpa do estudo sem as decis√µes anteriores
                    return {
                        ...study,
                        included: false,
                        excluded: false,
                        reasonExclusion: '',
                        observations: study.observations || ''
                    };
                });

                // Inicializa as decis√µes do novo revisor como vazias
                newReviewerDecisions = {};
                studies.forEach(study => {
                    newReviewerDecisions[study.id] = {
                        included: false,
                        excluded: false,
                        reasonExclusion: ''
                    };
                });

                displayEnhancedComparison();
                comparisonMode = true;

                // Fecha o modal e mostra os controles de compara√ß√£o
                closeCompareModal();
                document.getElementById('comparisonModeIndicator').classList.remove('hidden');

                // Mostra os dropdowns de filtro de compara√ß√£o
                document.getElementById('comparisonMainFilter').classList.remove('hidden');
                document.getElementById('comparisonScreeningFilter').classList.remove('hidden');

                // Mostra o bot√£o para salvar decis√µes do novo revisor
                document.getElementById('saveNewReviewerDecisionsBtn').classList.remove('hidden');

                // Atualiza as visualiza√ß√µes para mostrar os dados de compara√ß√£o
                applyFilters();

                alert(`‚úÖ Sess√£o iniciada! Ol√° ${newReviewerName}!\n\nüìä ${reviewersData.length} revisores carregados\nüìù ${studies.length} artigos para revisar\n\nüí° Use os modos Planilha ou Triagem para dar sua opini√£o sobre cada artigo.\n\n‚úÖ Quando terminar, clique em "Salvar Minhas Decis√µes" para adicionar suas escolhas √† compara√ß√£o.`);
            }).catch(error => {
                alert('Erro ao carregar arquivos: ' + error.message);
            });
        }

        function displayEnhancedComparison() {
            // Calculate comprehensive comparison data
            const studyComparisons = studies.map(study => {
                const decisions = reviewersData.map(r => {
                    const reviewerStudy = r.studies.find(s => s.id == study.id);
                    return {
                        reviewer: r.reviewer,
                        included: reviewerStudy ? reviewerStudy.included : false,
                        excluded: reviewerStudy ? reviewerStudy.excluded : false,
                        reasonExclusion: reviewerStudy ? reviewerStudy.reasonExclusion : ''
                    };
                });

                const includeCount = decisions.filter(d => d.included).length;
                const excludeCount = decisions.filter(d => d.excluded).length;
                const pendingCount = decisions.filter(d => !d.included && !d.excluded).length;

                const allIncluded = decisions.every(d => d.included);
                const allExcluded = decisions.every(d => d.excluded);
                const fullAgreement = allIncluded || allExcluded;
                
                const majorityInclude = includeCount > (decisions.length / 2);
                const majorityExclude = excludeCount > (decisions.length / 2);

                return {
                    study: study,
                    decisions: decisions,
                    includeCount: includeCount,
                    excludeCount: excludeCount,
                    pendingCount: pendingCount,
                    fullAgreement: fullAgreement,
                    hasConflict: !fullAgreement,
                    allIncluded: allIncluded,
                    allExcluded: allExcluded,
                    majorityInclude: majorityInclude,
                    majorityExclude: majorityExclude,
                    status: allIncluded ? 'full-include' : (allExcluded ? 'full-exclude' : 'conflict')
                };
            });

            comparisonData = studyComparisons;

            // Generate summary
            displayComparisonSummary(studyComparisons);
            
            // Generate reviewer checkboxes
            generateReviewerCheckboxes();
            
            // Apply default filter
            applyComparisonFilter();
        }

        function displayComparisonSummary(comparisons) {
            const fullAgreements = comparisons.filter(c => c.fullAgreement).length;
            const fullIncludes = comparisons.filter(c => c.allIncluded).length;
            const fullExcludes = comparisons.filter(c => c.allExcluded).length;
            const conflicts = comparisons.filter(c => c.hasConflict).length;
            const majorityIncludes = comparisons.filter(c => c.majorityInclude && !c.fullAgreement).length;
            const majorityExcludes = comparisons.filter(c => c.majorityExclude && !c.fullAgreement).length;
            const withPending = comparisons.filter(c => c.pendingCount > 0).length;

            // Calcula estat√≠sticas por revisor
            const reviewerStats = reviewersData.map(r => {
                const includedCount = r.studies.filter(s => s.included).length;
                const excludedCount = r.studies.filter(s => s.excluded).length;
                const pendingCount = r.studies.filter(s => !s.included && !s.excluded).length;
                return {
                    name: r.reviewer,
                    included: includedCount,
                    excluded: excludedCount,
                    pending: pendingCount
                };
            });

            const summaryHTML = `
                <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4 mb-6">
                    <div class="bg-white p-4 rounded-lg shadow border-2 border-gray-200">
                        <p class="text-sm text-gray-600 font-semibold">üìä Total de Estudos</p>
                        <p class="text-4xl font-bold text-gray-800">${studies.length}</p>
                    </div>
                    <div class="bg-green-100 p-4 rounded-lg shadow border-2 border-green-300">
                        <p class="text-sm text-green-700 font-semibold">‚úÖ Concord√¢ncia Total</p>
                        <p class="text-4xl font-bold text-green-800">${fullAgreements}</p>
                        <p class="text-xs text-green-600 mt-1">${((fullAgreements/studies.length)*100).toFixed(1)}% dos estudos</p>
                    </div>
                    <div class="bg-emerald-100 p-4 rounded-lg shadow border-2 border-emerald-300">
                        <p class="text-sm text-emerald-700 font-semibold">üü¢ Todos Incluem</p>
                        <p class="text-4xl font-bold text-emerald-800">${fullIncludes}</p>
                        <p class="text-xs text-emerald-600 mt-1">${((fullIncludes/studies.length)*100).toFixed(1)}%</p>
                    </div>
                    <div class="bg-rose-100 p-4 rounded-lg shadow border-2 border-rose-300">
                        <p class="text-sm text-rose-700 font-semibold">üî¥ Todos Excluem</p>
                        <p class="text-4xl font-bold text-rose-800">${fullExcludes}</p>
                        <p class="text-xs text-rose-600 mt-1">${((fullExcludes/studies.length)*100).toFixed(1)}%</p>
                    </div>
                    <div class="bg-yellow-100 p-4 rounded-lg shadow border-2 border-yellow-300">
                        <p class="text-sm text-yellow-700 font-semibold">‚ö†Ô∏è Conflitos</p>
                        <p class="text-4xl font-bold text-yellow-800">${conflicts}</p>
                        <p class="text-xs text-yellow-600 mt-1">${((conflicts/studies.length)*100).toFixed(1)}% precisam revis√£o</p>
                    </div>
                    <div class="bg-gray-100 p-4 rounded-lg shadow border-2 border-gray-300">
                        <p class="text-sm text-gray-700 font-semibold">‚ö™ Com Pend√™ncias</p>
                        <p class="text-4xl font-bold text-gray-800">${withPending}</p>
                        <p class="text-xs text-gray-600 mt-1">${((withPending/studies.length)*100).toFixed(1)}%</p>
                    </div>
                    <div class="bg-orange-100 p-4 rounded-lg shadow border-2 border-orange-300">
                        <p class="text-sm text-orange-700 font-semibold">üìà Maioria Inclui</p>
                        <p class="text-4xl font-bold text-orange-800">${majorityIncludes}</p>
                    </div>
                    <div class="bg-red-100 p-4 rounded-lg shadow border-2 border-red-300">
                        <p class="text-sm text-red-700 font-semibold">üìâ Maioria Exclui</p>
                        <p class="text-4xl font-bold text-red-800">${majorityExcludes}</p>
                    </div>
                </div>

                <div class="bg-blue-50 border-2 border-blue-200 rounded-lg p-4 mb-4">
                    <h4 class="font-bold text-lg text-blue-800 mb-3">üë• Estat√≠sticas por Revisor</h4>
                    <div class="grid grid-cols-1 md:grid-cols-${Math.min(reviewerStats.length, 3)} gap-4">
                        ${reviewerStats.map(stat => `
                            <div class="bg-white p-3 rounded-lg border">
                                <p class="font-semibold text-gray-800 mb-2">${stat.name}</p>
                                <div class="space-y-1 text-sm">
                                    <div class="flex justify-between">
                                        <span class="text-green-700">‚úÖ Inclu√≠dos:</span>
                                        <span class="font-bold text-green-800">${stat.included}</span>
                                    </div>
                                    <div class="flex justify-between">
                                        <span class="text-red-700">‚ùå Exclu√≠dos:</span>
                                        <span class="font-bold text-red-800">${stat.excluded}</span>
                                    </div>
                                    <div class="flex justify-between">
                                        <span class="text-gray-600">‚ö™ Pendentes:</span>
                                        <span class="font-bold text-gray-700">${stat.pending}</span>
                                    </div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>

                <div class="text-sm text-gray-700 bg-white p-3 rounded border">
                    <p><strong>üìù Revisores na Compara√ß√£o:</strong> ${reviewersData.map(r => r.reviewer).join(', ')}</p>
                </div>
            `;

            document.getElementById('comparisonSummary').innerHTML = summaryHTML;
        }

        function generateReviewerCheckboxes() {
            const container = document.getElementById('reviewerCheckboxes');
            container.innerHTML = '';

            reviewersData.forEach((reviewer, index) => {
                const checkbox = document.createElement('div');
                checkbox.className = 'flex items-center gap-2 p-2 bg-gray-50 rounded';
                checkbox.innerHTML = `
                    <input type="checkbox" 
                           id="reviewer_${index}" 
                           value="${index}"
                           checked
                           class="reviewer-checkbox">
                    <label for="reviewer_${index}" class="text-sm cursor-pointer">${reviewer.reviewer}</label>
                `;
                container.appendChild(checkbox);
            });

            // Select all by default
            selectedReviewersForExport = reviewersData.map((r, i) => i);
        }

        function applyReviewerSelection() {
            const checkboxes = document.querySelectorAll('.reviewer-checkbox');
            selectedReviewersForExport = [];
            
            checkboxes.forEach((cb, index) => {
                if (cb.checked) {
                    selectedReviewersForExport.push(index);
                }
            });

            if (selectedReviewersForExport.length < 1) {
                alert('Selecione pelo menos 1 revisor!');
                return;
            }

            // Recalculate comparison based on selected reviewers
            const filteredComparisons = comparisonData.map(comp => {
                const filteredDecisions = comp.decisions.filter((d, i) => 
                    selectedReviewersForExport.includes(i)
                );

                const includeCount = filteredDecisions.filter(d => d.included).length;
                const excludeCount = filteredDecisions.filter(d => d.excluded).length;
                const allIncluded = filteredDecisions.every(d => d.included);
                const allExcluded = filteredDecisions.every(d => d.excluded);

                return {
                    ...comp,
                    filteredDecisions: filteredDecisions,
                    filteredIncludeCount: includeCount,
                    filteredExcludeCount: excludeCount,
                    filteredFullAgreement: allIncluded || allExcluded,
                    filteredAllIncluded: allIncluded,
                    filteredAllExcluded: allExcluded
                };
            });

            showToast(`Filtrando por ${selectedReviewersForExport.length} revisor(es) selecionado(s)`, 'info');
            renderDetailedComparisonTable(filteredComparisons);
        }

        function applyComparisonFilter() {
            const filterValue = document.getElementById('comparisonFilterSelect').value;
            comparisonFilter = filterValue;

            let filteredComparisons = comparisonData;

            switch(filterValue) {
                case 'full-agreement':
                    filteredComparisons = comparisonData.filter(c => c.fullAgreement);
                    break;
                case 'full-include':
                    filteredComparisons = comparisonData.filter(c => c.allIncluded);
                    break;
                case 'full-exclude':
                    filteredComparisons = comparisonData.filter(c => c.allExcluded);
                    break;
                case 'conflicts':
                    filteredComparisons = comparisonData.filter(c => c.hasConflict);
                    break;
                case 'majority-include':
                    filteredComparisons = comparisonData.filter(c => c.majorityInclude && !c.fullAgreement);
                    break;
                case 'majority-exclude':
                    filteredComparisons = comparisonData.filter(c => c.majorityExclude && !c.fullAgreement);
                    break;
                default:
                    filteredComparisons = comparisonData;
            }

            renderDetailedComparisonTable(filteredComparisons);
            
            // Update count
            document.getElementById('filteredStudiesCount').textContent = filteredComparisons.length;
        }

        function renderDetailedComparisonTable(comparisons) {
            const container = document.getElementById('detailedComparisonTable');
            
            if (comparisons.length === 0) {
                container.innerHTML = `
                    <div class="p-8 text-center text-gray-500">
                        <p class="text-lg">Nenhum estudo encontrado com este filtro.</p>
                    </div>
                `;
                return;
            }

            let html = '<div class="divide-y">';

            comparisons.forEach((comp, index) => {
                const bgClass = comp.fullAgreement ? 'bg-green-50' : 'bg-red-50';
                
                html += `
                    <div class="${bgClass} p-4 hover:bg-opacity-75 transition">
                        <div class="flex justify-between items-start mb-2">
                            <div class="flex-1">
                                <h4 class="font-semibold text-sm mb-1">${comp.study.title}</h4>
                                <p class="text-xs text-gray-600">${comp.study.authors[0] || ''} ${comp.study.year}</p>
                            </div>
                            <div class="flex gap-2 ml-4">
                                ${comp.fullAgreement ? 
                                    '<span class="px-2 py-1 bg-green-500 text-white rounded text-xs">‚úì Acordo</span>' : 
                                    '<span class="px-2 py-1 bg-red-500 text-white rounded text-xs">‚ö† Conflito</span>'
                                }
                            </div>
                        </div>
                        <div class="grid grid-cols-${Math.min(reviewersData.length, 4)} gap-2 mt-3">
                            ${comp.decisions.map(d => {
                                const decisionIcon = d.included ? '‚úÖ' : (d.excluded ? '‚ùå' : '‚ö™');
                                const decisionText = d.included ? 'INCLUIR' : (d.excluded ? 'EXCLUIR' : 'PENDENTE');
                                const decisionColor = d.included ? 'text-green-700 bg-green-100' : (d.excluded ? 'text-red-700 bg-red-100' : 'text-gray-700 bg-gray-100');
                                return `
                                    <div class="${decisionColor} p-2 rounded text-xs">
                                        <p class="font-semibold">${d.reviewer}</p>
                                        <p class="mt-1">${decisionIcon} ${decisionText}</p>
                                        ${d.reasonExclusion ? `<p class="mt-1 text-xs italic">${d.reasonExclusion.substring(0, 50)}...</p>` : ''}
                                    </div>
                                `;
                            }).join('')}
                        </div>
                        <div class="mt-2 text-xs text-gray-600">
                            <span class="font-semibold">Contagem:</span> 
                            ${comp.includeCount} incluir | ${comp.excludeCount} excluir | ${comp.pendingCount} pendente
                        </div>
                    </div>
                `;
            });

            html += '</div>';
            container.innerHTML = html;
        }

        function exportComparisonSpreadsheet(exportType) {
            if (!comparisonData || !reviewersData) {
                alert('Nenhuma compara√ß√£o ativa para exportar!');
                return;
            }

            let studiesToExport = [];
            let exportFileName = '';

            switch(exportType) {
                case 'current-filter':
                    // Export based on current filter
                    studiesToExport = getStudiesByComparisonFilter();
                    const filterNames = {
                        'all': 'Todos',
                        'full-agreement': 'Concordancia_Total',
                        'full-include': 'Todos_Incluem',
                        'full-exclude': 'Todos_Excluem',
                        'conflicts': 'Conflitos',
                        'majority-include': 'Maioria_Inclui',
                        'majority-exclude': 'Maioria_Exclui'
                    };
                    exportFileName = `Comparacao_${filterNames[comparisonFilter]}_${Date.now()}.xlsx`;
                    break;

                case 'selected-reviewers':
                    // Export studies where selected reviewers agree
                    studiesToExport = getStudiesBySelectedReviewers();
                    exportFileName = `Comparacao_Revisores_Selecionados_${Date.now()}.xlsx`;
                    break;

                case 'consensus':
                    // Export only studies where ALL reviewers agree
                    studiesToExport = comparisonData
                        .filter(c => c.fullAgreement)
                        .map(c => c.study);
                    exportFileName = `Comparacao_Consenso_Total_${Date.now()}.xlsx`;
                    break;

                case 'conflicts-only':
                    // Export only conflicted studies
                    studiesToExport = comparisonData
                        .filter(c => c.hasConflict)
                        .map(c => c.study);
                    exportFileName = `Comparacao_Conflitos_${Date.now()}.xlsx`;
                    break;

                default:
                    studiesToExport = studies;
                    exportFileName = `Comparacao_Export_${Date.now()}.xlsx`;
            }

            if (studiesToExport.length === 0) {
                alert('Nenhum estudo encontrado com este crit√©rio de exporta√ß√£o!');
                return;
            }

            // Create detailed spreadsheet with reviewer decisions
            const data = studiesToExport.map(study => {
                const authorText = study.authors && study.authors.length > 0 
                    ? study.authors[0] + (study.authors.length > 1 ? ' et al.' : '')
                    : '';
                const studyId = authorText && study.year 
                    ? `${authorText}, ${study.year}`
                    : study.id;

                // Get comparison data for this study
                const compData = comparisonData.find(c => c.study.id === study.id);
                
                const baseData = {
                    'STUDY ID': studyId,
                    'TITLE': study.title,
                    'AUTHOR': study.authors.join(', '),
                    'YEAR': study.year,
                    'DOI': study.doi || '',
                    'ABSTRACT': study.abstract || ''
                };

                // Add each reviewer's decision as columns
                if (compData) {
                    compData.decisions.forEach(d => {
                        const decisionText = d.included ? 'INCLUDE' : (d.excluded ? 'EXCLUDE' : 'PENDING');
                        baseData[`${d.reviewer}_DECISION`] = decisionText;
                        baseData[`${d.reviewer}_REASON`] = d.reasonExclusion || '';
                    });

                    // Add summary columns
                    baseData['INCLUDE_COUNT'] = compData.includeCount;
                    baseData['EXCLUDE_COUNT'] = compData.excludeCount;
                    baseData['AGREEMENT'] = compData.fullAgreement ? 'YES' : 'NO';
                    baseData['STATUS'] = compData.allIncluded ? 'ALL_INCLUDE' : 
                                        (compData.allExcluded ? 'ALL_EXCLUDE' : 'CONFLICT');
                }

                return baseData;
            });

            const ws = XLSX.utils.json_to_sheet(data);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, 'Comparison');
            XLSX.writeFile(wb, exportFileName);

            showToast(`Planilha exportada com ${studiesToExport.length} estudos!`, 'success');
        }

        function getStudiesByComparisonFilter() {
            let filtered = comparisonData;

            switch(comparisonFilter) {
                case 'full-agreement':
                    filtered = comparisonData.filter(c => c.fullAgreement);
                    break;
                case 'full-include':
                    filtered = comparisonData.filter(c => c.allIncluded);
                    break;
                case 'full-exclude':
                    filtered = comparisonData.filter(c => c.allExcluded);
                    break;
                case 'conflicts':
                    filtered = comparisonData.filter(c => c.hasConflict);
                    break;
                case 'majority-include':
                    filtered = comparisonData.filter(c => c.majorityInclude && !c.fullAgreement);
                    break;
                case 'majority-exclude':
                    filtered = comparisonData.filter(c => c.majorityExclude && !c.fullAgreement);
                    break;
                default:
                    filtered = comparisonData;
            }

            return filtered.map(c => c.study);
        }

        function getStudiesBySelectedReviewers() {
            if (selectedReviewersForExport.length === 0) {
                return [];
            }

            // Get studies where selected reviewers agree
            const filtered = comparisonData.filter(comp => {
                const selectedDecisions = comp.decisions.filter((d, i) => 
                    selectedReviewersForExport.includes(i)
                );

                const allInclude = selectedDecisions.every(d => d.included);
                const allExclude = selectedDecisions.every(d => d.excluded);

                return allInclude || allExclude;
            });

            return filtered.map(c => c.study);
        }

        function getComparisonClass(study) {
            if (!comparisonData) return '';
            const comparison = comparisonData.find(c => c.study.id == study.id);
            return comparison && comparison.agreement ? 'comparison-match' : 'comparison-conflict';
        }

        function getConsensusClass(study) {
            if (!comparisonMode || !comparisonData) return '';

            const comparison = comparisonData.find(c => c.study.id == study.id);
            if (!comparison) return '';

            if (comparison.allIncluded) {
                return 'consensus-include';
            } else if (comparison.allExcluded) {
                return 'consensus-exclude';
            } else if (comparison.hasConflict) {
                return 'consensus-conflict';
            } else if (comparison.pendingCount > 0) {
                return 'consensus-pending';
            }

            return '';
        }

        function getConsensusInfo(study) {
            if (!comparisonMode || !comparisonData) return null;

            const comparison = comparisonData.find(c => c.study.id == study.id);
            if (!comparison) return null;

            return {
                includeCount: comparison.includeCount,
                excludeCount: comparison.excludeCount,
                pendingCount: comparison.pendingCount,
                allIncluded: comparison.allIncluded,
                allExcluded: comparison.allExcluded,
                hasConflict: comparison.hasConflict,
                decisions: comparison.decisions
            };
        }

        function toggleOtherReviewersVisibility() {
            showOtherReviewersDecisions = !showOtherReviewersDecisions;
            const btn = document.getElementById('toggleReviewersVisibility');

            if (showOtherReviewersDecisions) {
                btn.textContent = 'üëÅÔ∏è Mostrar Decis√µes dos Outros';
                btn.classList.remove('bg-gray-500', 'hover:bg-gray-600');
                btn.classList.add('bg-blue-600', 'hover:bg-blue-700');
            } else {
                btn.textContent = 'üôà Ocultar Decis√µes dos Outros';
                btn.classList.remove('bg-blue-600', 'hover:bg-blue-700');
                btn.classList.add('bg-gray-500', 'hover:bg-gray-600');
            }

            // Atualiza as visualiza√ß√µes
            if (currentView === 'spreadsheet') {
                renderSpreadsheet();
            } else {
                renderScreeningCards();
            }
        }

        function showAdvancedExportModal() {
            if (!comparisonMode || !reviewersData || reviewersData.length === 0) {
                alert('Nenhuma compara√ß√£o ativa! Carregue revisores primeiro.');
                return;
            }

            // Popula a lista de revisores
            const reviewersList = document.getElementById('advancedExportReviewersList');
            reviewersList.innerHTML = reviewersData.map((r, index) => `
                <label class="flex items-center gap-2 p-2 border rounded hover:bg-gray-50 cursor-pointer">
                    <input type="checkbox" class="advanced-export-reviewer-checkbox" data-reviewer-index="${index}" checked>
                    <span class="text-sm">${r.reviewer}</span>
                </label>
            `).join('');

            // Adiciona listeners para atualizar preview
            document.querySelectorAll('.advanced-export-reviewer-checkbox').forEach(cb => {
                cb.addEventListener('change', updateAdvancedExportPreview);
            });
            document.getElementById('advancedExportConsensusType').addEventListener('change', updateAdvancedExportPreview);

            updateAdvancedExportPreview();
            document.getElementById('advancedExportModal').style.display = 'block';
        }

        function closeAdvancedExportModal() {
            document.getElementById('advancedExportModal').style.display = 'none';
        }

        function updateAdvancedExportPreview() {
            const selectedReviewerIndices = Array.from(document.querySelectorAll('.advanced-export-reviewer-checkbox:checked'))
                .map(cb => parseInt(cb.dataset.reviewerIndex));
            const consensusType = document.getElementById('advancedExportConsensusType').value;

            if (selectedReviewerIndices.length === 0) {
                document.getElementById('advancedExportPreview').textContent = 'Selecione pelo menos um revisor';
                return;
            }

            // Calcula quantos artigos atendem os crit√©rios
            const matchingStudies = comparisonData.filter(comp => {
                const selectedDecisions = comp.decisions.filter((d, i) => selectedReviewerIndices.includes(i));

                if (selectedDecisions.length === 0) return false;

                switch (consensusType) {
                    case 'all-agree-include':
                        return selectedDecisions.every(d => d.included);
                    case 'all-agree-exclude':
                        return selectedDecisions.every(d => d.excluded);
                    case 'all-agree-any':
                        const allInclude = selectedDecisions.every(d => d.included);
                        const allExclude = selectedDecisions.every(d => d.excluded);
                        return allInclude || allExclude;
                    case 'any-include':
                        return selectedDecisions.some(d => d.included);
                    case 'any-exclude':
                        return selectedDecisions.some(d => d.excluded);
                    case 'majority-include':
                        const includeCount = selectedDecisions.filter(d => d.included).length;
                        return includeCount > (selectedDecisions.length / 2);
                    case 'majority-exclude':
                        const excludeCount = selectedDecisions.filter(d => d.excluded).length;
                        return excludeCount > (selectedDecisions.length / 2);
                    default:
                        return false;
                }
            });

            const reviewerNames = selectedReviewerIndices.map(i => reviewersData[i].reviewer).join(', ');
            document.getElementById('advancedExportPreview').textContent =
                `${matchingStudies.length} artigos encontrados (Revisores: ${reviewerNames})`;
        }

        function executeAdvancedExport() {
            const selectedReviewerIndices = Array.from(document.querySelectorAll('.advanced-export-reviewer-checkbox:checked'))
                .map(cb => parseInt(cb.dataset.reviewerIndex));
            const consensusType = document.getElementById('advancedExportConsensusType').value;
            const customFilename = document.getElementById('advancedExportFilename').value.trim();

            if (selectedReviewerIndices.length === 0) {
                alert('Selecione pelo menos um revisor!');
                return;
            }

            // Filtra os estudos de acordo com os crit√©rios
            const matchingComparisons = comparisonData.filter(comp => {
                const selectedDecisions = comp.decisions.filter((d, i) => selectedReviewerIndices.includes(i));

                if (selectedDecisions.length === 0) return false;

                switch (consensusType) {
                    case 'all-agree-include':
                        return selectedDecisions.every(d => d.included);
                    case 'all-agree-exclude':
                        return selectedDecisions.every(d => d.excluded);
                    case 'all-agree-any':
                        const allInclude = selectedDecisions.every(d => d.included);
                        const allExclude = selectedDecisions.every(d => d.excluded);
                        return allInclude || allExclude;
                    case 'any-include':
                        return selectedDecisions.some(d => d.included);
                    case 'any-exclude':
                        return selectedDecisions.some(d => d.excluded);
                    case 'majority-include':
                        const includeCount = selectedDecisions.filter(d => d.included).length;
                        return includeCount > (selectedDecisions.length / 2);
                    case 'majority-exclude':
                        const excludeCount = selectedDecisions.filter(d => d.excluded).length;
                        return excludeCount > (selectedDecisions.length / 2);
                    default:
                        return false;
                }
            });

            if (matchingComparisons.length === 0) {
                alert('Nenhum artigo atende aos crit√©rios selecionados!');
                return;
            }

            // Gera o arquivo Excel
            const data = matchingComparisons.map(compData => {
                const study = compData.study;
                const baseData = {
                    ID: study.id,
                    TITLE: study.title,
                    AUTHOR: study.authors[0] || '',
                    YEAR: study.year,
                    DOI: study.doi || '',
                    ABSTRACT: study.abstract || ''
                };

                // Adiciona colunas de decis√£o de cada revisor
                compData.decisions.forEach(d => {
                    const decisionText = d.included ? 'INCLUDE' : (d.excluded ? 'EXCLUDE' : 'PENDING');
                    baseData[`${d.reviewer}_DECISION`] = decisionText;
                    baseData[`${d.reviewer}_REASON`] = d.reasonExclusion || '';
                });

                // Adiciona colunas de resumo
                baseData['INCLUDE_COUNT'] = compData.includeCount;
                baseData['EXCLUDE_COUNT'] = compData.excludeCount;
                baseData['PENDING_COUNT'] = compData.pendingCount;
                baseData['AGREEMENT'] = compData.fullAgreement ? 'YES' : 'NO';
                baseData['STATUS'] = compData.allIncluded ? 'ALL_INCLUDE' :
                                    (compData.allExcluded ? 'ALL_EXCLUDE' : 'CONFLICT');

                return baseData;
            });

            const ws = XLSX.utils.json_to_sheet(data);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, 'Export');

            // Define o nome do arquivo
            const filename = customFilename || `Comparison_Advanced_${Date.now()}.xlsx`;
            XLSX.writeFile(wb, filename.endsWith('.xlsx') ? filename : `${filename}.xlsx`);

            showToast(`‚úÖ Planilha exportada com ${matchingComparisons.length} artigos!`, 'success');
            closeAdvancedExportModal();
        }

        function saveNewReviewerDecisions() {
            if (!comparisonMode || !newReviewerName) {
                alert('Nenhuma sess√£o de compara√ß√£o ativa!');
                return;
            }

            // Verifica se h√° decis√µes a salvar
            const decisionsCount = studies.filter(s => s.included || s.excluded).length;
            if (decisionsCount === 0) {
                alert('Voc√™ ainda n√£o fez nenhuma decis√£o! Revise alguns artigos primeiro.');
                return;
            }

            // Adiciona o novo revisor aos reviewersData
            const newReviewerData = {
                reviewer: newReviewerName,
                studies: studies.map(s => ({
                    id: s.id,
                    title: s.title,
                    authors: s.authors,
                    year: s.year,
                    doi: s.doi,
                    abstract: s.abstract,
                    included: s.included,
                    excluded: s.excluded,
                    reasonExclusion: s.reasonExclusion || '',
                    observations: s.observations || ''
                }))
            };

            reviewersData.push(newReviewerData);

            // Atualiza comparisonData para incluir o novo revisor
            displayEnhancedComparison();

            // Exibe mensagem de sucesso
            alert(`‚úÖ Suas decis√µes foram salvas com sucesso!\n\nüìä ${decisionsCount} decis√µes registradas\nüë§ Revisor: ${newReviewerName}\n\nüí° Agora voc√™ pode exportar a compara√ß√£o atualizada incluindo suas decis√µes.`);

            // Atualiza visualiza√ß√µes
            applyFilters();

            showToast(`Decis√µes de ${newReviewerName} adicionadas √† compara√ß√£o!`, 'success');
        }

        let picoFields = [
            { label: 'POPULATION', placeholder: 'Describe your population/participants...', value: '' },
            { label: 'INTERVENTION', placeholder: 'Describe the intervention/exposure...', value: '' },
            { label: 'COMPARISON', placeholder: 'Describe the comparison/control (if applicable)...', value: '' },
            { label: 'OUTCOME', placeholder: 'Describe the outcomes of interest...', value: '' }
        ];
        let parsedClaudeDecisions = [];
        let rawClaudeData = null;
        let detectedColumns = [];
        let decisionColumnIndex = -1;

        function showClaudeCommandModal() {
            renderPicoFields();
            document.getElementById('claudeCommandModal').style.display = 'block';

            // Restore previously remembered filter or use 'all'
            const filterElement = document.getElementById('claudeCommandFilter');
            filterElement.value = rememberedFilter || 'all';

            // Update filter (this may reset range values, so we'll restore them after)
            updateClaudeCommandFilter();

            // Restore previously remembered range values
            // Use both immediate and delayed execution to ensure values stick
            const rangeStartEl = document.getElementById('rangeStart');
            const rangeEndEl = document.getElementById('rangeEnd');

            if (rememberedRangeStart !== null && rememberedRangeStart !== '') {
                rangeStartEl.value = rememberedRangeStart;
            }
            if (rememberedRangeEnd !== null && rememberedRangeEnd !== '') {
                rangeEndEl.value = rememberedRangeEnd;
            }

            // Set again with delay to override any resets from updateClaudeCommandFilter
            setTimeout(() => {
                if (rememberedRangeStart !== null && rememberedRangeStart !== '') {
                    rangeStartEl.value = rememberedRangeStart;
                }
                if (rememberedRangeEnd !== null && rememberedRangeEnd !== '') {
                    rangeEndEl.value = rememberedRangeEnd;
                }
            }, 100);
        }

        function closeClaudeCommandModal() {
            // Save current values before closing
            rememberedRangeStart = document.getElementById('rangeStart').value || null;
            rememberedRangeEnd = document.getElementById('rangeEnd').value || null;
            rememberedFilter = document.getElementById('claudeCommandFilter').value || 'all';

            document.getElementById('claudeCommandModal').style.display = 'none';
        }

        function renderPicoFields() {
            const container = document.getElementById('picoFieldsContainer');
            container.innerHTML = '';

            picoFields.forEach((field, index) => {
                const fieldDiv = document.createElement('div');
                fieldDiv.className = 'mb-2 flex gap-2 items-start';
                fieldDiv.innerHTML = `
                    <div class="flex-1">
                        <input type="text" 
                            id="picoFieldLabel_${index}" 
                            value="${field.label}" 
                            placeholder="Label (ex: POPULATION)"
                            class="w-full border rounded px-2 py-1 text-xs font-semibold mb-1"
                            onchange="updatePicoFieldLabel(${index}, this.value)">
                        <textarea 
                            id="picoField_${index}" 
                            class="w-full border rounded p-2 text-sm" 
                            placeholder="${field.placeholder}" 
                            rows="2"
                            onchange="updatePicoFieldValue(${index}, this.value)">${field.value}</textarea>
                    </div>
                    <button onclick="removePicoField(${index})" 
                        class="text-red-500 hover:text-red-700 mt-6" 
                        title="Remover campo">
                        üóëÔ∏è
                    </button>
                `;
                container.appendChild(fieldDiv);
            });
        }

        function addPicoField() {
            const newFieldName = prompt('Nome do novo campo (ex: INTERVENTION 2, SETTING, TIMEFRAME):', 'CUSTOM FIELD');
            if (!newFieldName) return;

            picoFields.push({
                label: newFieldName.toUpperCase(),
                placeholder: `Describe ${newFieldName.toLowerCase()}...`,
                value: ''
            });
            renderPicoFields();
            showToast('Campo adicionado!', 'success');
        }

        function removePicoField(index) {
            if (picoFields.length <= 1) {
                alert('Voc√™ precisa de pelo menos 1 campo!');
                return;
            }
            if (confirm(`Remover campo "${picoFields[index].label}"?`)) {
                picoFields.splice(index, 1);
                renderPicoFields();
                showToast('Campo removido!', 'success');
            }
        }

        function updatePicoFieldLabel(index, value) {
            picoFields[index].label = value.toUpperCase();
        }

        function updatePicoFieldValue(index, value) {
            picoFields[index].value = value;
        }

        function resetPicoFields() {
            if (confirm('Resetar para campos padr√£o PICO?')) {
                picoFields = [
                    { label: 'POPULATION', placeholder: 'Describe your population/participants...', value: '' },
                    { label: 'INTERVENTION', placeholder: 'Describe the intervention/exposure...', value: '' },
                    { label: 'COMPARISON', placeholder: 'Describe the comparison/control (if applicable)...', value: '' },
                    { label: 'OUTCOME', placeholder: 'Describe the outcomes of interest...', value: '' }
                ];
                renderPicoFields();
                showToast('Campos resetados!', 'success');
            }
        }

        function updateRangeInfo() {
            const infoSpan = document.getElementById('rangeInfo');
            if (infoSpan) {
                infoSpan.textContent = `(Total: ${studies.length} estudos)`;
            }
            
            const rangeEnd = document.getElementById('rangeEnd');
            if (rangeEnd) {
                rangeEnd.max = studies.length;
                rangeEnd.placeholder = studies.length.toString();
            }
        }

        function updateClaudeCommandFilter() {
            const filterValue = document.getElementById('claudeCommandFilter').value;
            const filterInfo = document.getElementById('filterInfo');

            // Save the filter value
            rememberedFilter = filterValue;

            // Get filtered studies
            const filteredStudies = getClaudeCommandFilteredStudies();

            // Update range inputs
            const rangeStart = document.getElementById('rangeStart');
            const rangeEnd = document.getElementById('rangeEnd');
            const rangeInfo = document.getElementById('rangeInfo');

            if (filteredStudies.length === 0) {
                filterInfo.innerHTML = '‚ö†Ô∏è Nenhum estudo encontrado com este filtro!';
                filterInfo.classList.remove('hidden');
                filterInfo.classList.add('text-red-600');
                filterInfo.classList.remove('text-blue-600');

                rangeStart.value = '';
                rangeEnd.value = '';
                rangeInfo.textContent = '';
                return;
            }

            // Show filter info
            let filterText = '';
            if (filterValue === 'pending') {
                filterText = `‚ö™ ${filteredStudies.length} estudos pendentes encontrados`;
            } else if (filterValue === 'included') {
                filterText = `‚úÖ ${filteredStudies.length} estudos inclu√≠dos encontrados`;
            } else if (filterValue === 'excluded') {
                filterText = `‚ùå ${filteredStudies.length} estudos exclu√≠dos encontrados`;
            } else {
                filterText = `üìö Total: ${filteredStudies.length} estudos`;
            }

            filterInfo.innerHTML = filterText;
            filterInfo.classList.remove('hidden');
            filterInfo.classList.add('text-blue-600');
            filterInfo.classList.remove('text-red-600');

            // Update max values but don't reset the range if we have remembered values
            rangeStart.max = filteredStudies.length;
            rangeEnd.max = filteredStudies.length;
            rangeInfo.textContent = `(de ${filteredStudies.length} estudos filtrados)`;

            // Only set default values if there are no remembered values
            if (!rememberedRangeStart && !rememberedRangeEnd) {
                rangeStart.value = 1;
                rangeEnd.value = filteredStudies.length;
            }
        }

        function getClaudeCommandFilteredStudies() {
            const filterValue = document.getElementById('claudeCommandFilter').value;

            if (filterValue === 'all') {
                return studies;
            } else if (filterValue === 'pending') {
                return studies.filter(s => !s.included && !s.excluded);
            } else if (filterValue === 'included') {
                return studies.filter(s => s.included);
            } else if (filterValue === 'excluded') {
                return studies.filter(s => s.excluded);
            }

            return studies;
        }

        function generateClaudeCommand() {
            // Get filtered studies based on filter dropdown
            const filteredStudies = getClaudeCommandFilteredStudies();

            const start = parseInt(document.getElementById('rangeStart').value) || 1;
            const end = parseInt(document.getElementById('rangeEnd').value) || filteredStudies.length;

            if (start < 1 || end > filteredStudies.length || start > end) {
                alert(`Intervalo inv√°lido! Use valores entre 1 e ${filteredStudies.length}.`);
                return;
            }

            let picoSection = '';
            picoFields.forEach(field => {
                const value = field.value || '[PREENCHER]';
                picoSection += `${field.label}: ${value}\n`;
            });

            let command = `NOW, BASED IN THE FRAMEWORK BELOW, YOU WILL DECIDE BETWEEN INCLUDE OR EXCLUDE THE STUDIES. SO YOU WILL REWRITE THE TABLE (JUST TITLE, STATUS, AND REASON FOR EXCLUSION) WITH YOUR DECISION. THE STUDY DESIGN CAN BE ANY WITH PATIENT GROUPS:

${picoSection}
HERE THE TABLE:

| STUDY ID | TITLE | ABSTRACT | STATUS | REASON FOR EXCLUSION |
|----------|-------|----------|--------|---------------------|
`;

            const selectedStudies = filteredStudies.slice(start - 1, end);
            selectedStudies.forEach(study => {
                const authorText = study.authors && study.authors.length > 0
                    ? study.authors[0] + (study.authors.length > 1 ? ' et al.' : '')
                    : '';
                const studyId = authorText && study.year
                    ? `${authorText}, ${study.year}`
                    : study.id;

                const title = study.title.replace(/\|/g, '¬¶');
                // MODIFICADO: Abstract completo, sem substring
                const abstract = (study.abstract || 'N/A').replace(/\|/g, '¬¶').replace(/\n/g, ' ');

                command += `| ${studyId} | ${title} | ${abstract} | PENDING | - |\n`;
            });

            document.getElementById('claudeCommandText').value = command;
            document.getElementById('claudeCommandOutput').classList.remove('hidden');

            // Create success message with filter info
            const filterValue = document.getElementById('claudeCommandFilter').value;
            let filterInfo = '';
            if (filterValue === 'pending') {
                filterInfo = ' (apenas pendentes)';
            } else if (filterValue === 'included') {
                filterInfo = ' (apenas inclu√≠dos)';
            } else if (filterValue === 'excluded') {
                filterInfo = ' (apenas exclu√≠dos)';
            }

            navigator.clipboard.writeText(command).then(() => {
                showToast(`‚úÖ Comando copiado! ${selectedStudies.length} estudos selecionados${filterInfo}`, 'success');
            });
        }

        function showClaudeResponseParser() {
            document.getElementById('claudeResponseModal').style.display = 'block';
            document.getElementById('claudeResponsePreview').classList.add('hidden');
            document.getElementById('claudeResponseInput').value = '';
        }

        function closeClaudeResponseModal() {
            document.getElementById('claudeResponseModal').style.display = 'none';
        }

        function parseClaudeResponse() {
            const input = document.getElementById('claudeResponseInput').value.trim();

            if (!input) {
                alert('Cole a resposta do Claude primeiro!');
                return;
            }

            // Parse table and detect columns
            const tableData = parseMarkdownTableWithColumns(input);

            if (!tableData || tableData.rows.length === 0) {
                alert('N√£o foi poss√≠vel identificar uma tabela na resposta. Verifique o formato.');
                return;
            }

            rawClaudeData = tableData;
            detectedColumns = tableData.columns;

            // Populate column dropdown
            const select = document.getElementById('decisionColumnSelect');
            select.innerHTML = '<option value="">-- Selecione a coluna --</option>';

            detectedColumns.forEach((col, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = col;
                select.appendChild(option);
            });

            // Auto-detect decision column
            const decisionKeywords = ['status', 'decision', 'decis√£o', 'decisao', 'include', 'exclude'];
            decisionColumnIndex = detectedColumns.findIndex(col =>
                decisionKeywords.some(keyword => col.toLowerCase().includes(keyword))
            );

            if (decisionColumnIndex >= 0) {
                select.value = decisionColumnIndex;
                showToast(`Coluna "${detectedColumns[decisionColumnIndex]}" detectada automaticamente!`, 'success');
            }

            updateDecisionColumnMapping();
            document.getElementById('claudeResponsePreview').classList.remove('hidden');
        }

        function parseMarkdownTableWithColumns(text) {
            const lines = text.split('\n');
            const tableLines = lines.filter(line => line.includes('|') && !line.match(/^[\s]*\|[\s-:]+\|/));

            if (tableLines.length < 2) return null;

            // Get headers
            const headerLine = tableLines[0];
            const columns = headerLine.split('|').map(c => c.trim()).filter(c => c);

            // Get data rows
            const rows = [];
            tableLines.slice(1).forEach(line => {
                const cells = line.split('|').map(c => c.trim()).filter(c => c);
                if (cells.length >= columns.length) {
                    const row = {};
                    columns.forEach((col, index) => {
                        row[col] = cells[index] || '';
                    });
                    rows.push(row);
                }
            });

            return { columns, rows };
        }

        function updateDecisionColumnMapping() {
            if (!rawClaudeData) return;

            const selectedIndex = parseInt(document.getElementById('decisionColumnSelect').value);
            if (selectedIndex < 0 || isNaN(selectedIndex)) {
                return;
            }

            decisionColumnIndex = selectedIndex;
            const decisionColumn = detectedColumns[decisionColumnIndex];

            parsedClaudeDecisions = [];

            rawClaudeData.rows.forEach(row => {
                // Find study ID column (usually first column or contains author names)
                const studyId = row[detectedColumns[0]] || '';

                // Find title column (usually second column or contains "title")
                const titleColIndex = detectedColumns.findIndex(c => c.toLowerCase().includes('title') || c.toLowerCase().includes('t√≠tulo'));
                const title = titleColIndex >= 0 ? row[detectedColumns[titleColIndex]] : row[detectedColumns[1]] || '';

                // Get decision from selected column
                const rawDecision = row[decisionColumn] || '';
                const decision = normalizeDecision(rawDecision);

                // Find reason column
                const reasonColIndex = detectedColumns.findIndex(c =>
                    c.toLowerCase().includes('reason') ||
                    c.toLowerCase().includes('exclusion') ||
                    c.toLowerCase().includes('motivo')
                );
                const reason = reasonColIndex >= 0 ? row[detectedColumns[reasonColIndex]] : '';

                const matchedStudy = findMatchingStudy(studyId, title);

                parsedClaudeDecisions.push({
                    studyId,
                    title,
                    decision,
                    rawDecision,
                    reason,
                    matchedStudy
                });
            });

            renderClaudeDecisionsPreview();

            const matchCount = parsedClaudeDecisions.filter(d => d.matchedStudy).length;
            showToast(`${parsedClaudeDecisions.length} decis√µes processadas, ${matchCount} com match!`, 'success');
        }

        function normalizeDecision(rawDecision) {
            const upper = rawDecision.toUpperCase().trim();
            if (upper.includes('INCLUDE') || upper.includes('INCLUIR') || upper === 'I') {
                return 'include';
            } else if (upper.includes('EXCLUDE') || upper.includes('EXCLUIR') || upper === 'E') {
                return 'exclude';
            }
            return 'pending';
        }

        function parseMarkdownTable(text) {
            const decisions = [];
            const lines = text.split('\n');
            
            const tableLines = lines.filter(line => line.includes('|') && !line.match(/^[\s]*\|[\s-:]+\|/));
            
            if (tableLines.length < 2) return null;
            
            const dataRows = tableLines.slice(1).filter(line => {
                const cells = line.split('|').map(c => c.trim()).filter(c => c);
                return cells.length >= 3;
            });

            dataRows.forEach(line => {
                const cells = line.split('|').map(c => c.trim()).filter(c => c);
                
                if (cells.length >= 3) {
                    const studyId = cells[0];
                    const title = cells[1];
                    const status = cells[2];
                    const reason = cells[3] || '';

                    const statusUpper = status.toUpperCase();
                    let decision = 'pending';
                    if (statusUpper.includes('INCLUDE') || statusUpper.includes('INCLUIR')) {
                        decision = 'include';
                    } else if (statusUpper.includes('EXCLUDE') || statusUpper.includes('EXCLUIR')) {
                        decision = 'exclude';
                    }

                    decisions.push({
                        studyId: studyId,
                        title: title,
                        decision: decision,
                        reason: reason,
                        matchedStudy: null
                    });
                }
            });

            return decisions.length > 0 ? decisions : null;
        }

        function parseTextTable(text) {
            return parseMarkdownTable(text);
        }

        function parseBulletList(text) {
            const decisions = [];
            const lines = text.split('\n');
            
            lines.forEach(line => {
                const bulletMatch = line.match(/^[\s]*[-*‚Ä¢]\s*(.+?)\s*[-:]\s*(INCLUDE|EXCLUDE|INCLUIR|EXCLUIR)/i);
                if (bulletMatch) {
                    const studyId = bulletMatch[1].trim();
                    const statusMatch = bulletMatch[2].toUpperCase();
                    const decision = statusMatch.includes('INCLUDE') || statusMatch.includes('INCLUIR') ? 'include' : 'exclude';
                    
                    const reasonMatch = line.match(/(?:INCLUDE|EXCLUDE|INCLUIR|EXCLUIR)[\s:-]*(.+)$/i);
                    const reason = reasonMatch ? reasonMatch[1].trim() : '';

                    decisions.push({
                        studyId: studyId,
                        title: '',
                        decision: decision,
                        reason: reason,
                        matchedStudy: null
                    });
                }
            });

            return decisions.length > 0 ? decisions : null;
        }

        function parseSimpleLines(text) {
            const decisions = [];
            const lines = text.split('\n');
            
            lines.forEach(line => {
                const match = line.match(/(.+?)\s*[-:]\s*(INCLUDE|EXCLUDE|INCLUIR|EXCLUIR)/i);
                if (match) {
                    const studyId = match[1].trim();
                    const statusMatch = match[2].toUpperCase();
                    const decision = statusMatch.includes('INCLUDE') || statusMatch.includes('INCLUIR') ? 'include' : 'exclude';
                    
                    const reasonMatch = line.match(/(?:INCLUDE|EXCLUDE|INCLUIR|EXCLUIR)[\s:-]*(.+)$/i);
                    const reason = reasonMatch ? reasonMatch[1].trim() : '';

                    decisions.push({
                        studyId: studyId,
                        title: '',
                        decision: decision,
                        reason: reason,
                        matchedStudy: null
                    });
                }
            });

            return decisions.length > 0 ? decisions : null;
        }

        function findMatchingStudy(studyId, title) {
            let match = studies.find(s => {
                const authorText = s.authors && s.authors.length > 0 
                    ? s.authors[0] + (s.authors.length > 1 ? ' et al.' : '')
                    : '';
                const fullId = authorText && s.year ? `${authorText}, ${s.year}` : s.id.toString();
                return fullId === studyId || s.id.toString() === studyId;
            });

            if (match) return match;

            if (title) {
                const titleLower = title.toLowerCase();
                match = studies.find(s => {
                    const studyTitleLower = s.title.toLowerCase();
                    return studyTitleLower.includes(titleLower) || titleLower.includes(studyTitleLower);
                });
            }

            if (match) return match;

            const authorMatch = studyId.match(/^([A-Za-z]+)/);
            if (authorMatch) {
                const authorName = authorMatch[1];
                match = studies.find(s => 
                    s.authors && s.authors.length > 0 && 
                    s.authors[0].toLowerCase().includes(authorName.toLowerCase())
                );
            }

            return match;
        }

        function renderClaudeDecisionsPreview() {
            const tbody = document.getElementById('claudeResponseTableBody');
            tbody.innerHTML = '';

            parsedClaudeDecisions.forEach((decision, index) => {
                const row = document.createElement('tr');

                // Apply color based on decision (not just match status)
                let rowClass = '';
                if (decision.decision === 'include') {
                    rowClass = 'row-included';
                } else if (decision.decision === 'exclude') {
                    rowClass = 'row-excluded';
                } else {
                    rowClass = 'row-pending';
                }

                // Override with match indicator if no match found
                if (!decision.matchedStudy) {
                    row.style.opacity = '0.6';
                }

                row.className = rowClass;

                const matchBadge = decision.matchedStudy
                    ? '<span class="text-green-600 font-bold">‚úì</span>'
                    : '<span class="text-red-600 font-bold">‚úó</span>';

                // Create dropdown for decision
                const decisionDropdown = `
                    <select class="border rounded px-2 py-1 text-xs" onchange="updateClaudeDecision(${index}, this.value)">
                        <option value="include" ${decision.decision === 'include' ? 'selected' : ''}>INCLUDE</option>
                        <option value="exclude" ${decision.decision === 'exclude' ? 'selected' : ''}>EXCLUDE</option>
                        <option value="pending" ${decision.decision === 'pending' ? 'selected' : ''}>PENDING</option>
                    </select>
                `;

                row.innerHTML = `
                    <td class="border p-2">${decision.studyId}</td>
                    <td class="border p-2">${decision.title || (decision.matchedStudy ? decision.matchedStudy.title.substring(0, 50) + '...' : '-')}</td>
                    <td class="border p-2 text-center">${decisionDropdown}</td>
                    <td class="border p-2">${decision.reason || '-'}</td>
                    <td class="border p-2 text-center">${matchBadge}</td>
                `;
                tbody.appendChild(row);
            });
        }

        function updateClaudeDecision(index, newDecision) {
            if (parsedClaudeDecisions[index]) {
                parsedClaudeDecisions[index].decision = newDecision;
                renderClaudeDecisionsPreview(); // Re-render to update colors
                showToast(`Decis√£o atualizada para: ${newDecision.toUpperCase()}`, 'success');
            }
        }

        function applyClaudeDecisions() {
            const matchedDecisions = parsedClaudeDecisions.filter(d => d.matchedStudy);
            
            if (matchedDecisions.length === 0) {
                alert('Nenhuma decis√£o com match encontrada!');
                return;
            }

            const confirmMsg = `Aplicar ${matchedDecisions.length} decis√µes?\n\n` +
                `Isto ir√° atualizar os estudos correspondentes com as decis√µes do Claude.`;
            
            if (!confirm(confirmMsg)) return;

            let appliedCount = 0;
            matchedDecisions.forEach(decision => {
                const study = decision.matchedStudy;
                
                if (decision.decision === 'include') {
                    study.included = true;
                    study.excluded = false;
                    if (decision.reason && decision.reason !== '-') {
                        study.observations = decision.reason;
                        study.reasonExclusion = '';
                    }
                } else if (decision.decision === 'exclude') {
                    study.included = false;
                    study.excluded = true;
                    if (decision.reason) {
                        study.reasonExclusion = decision.reason;
                    }
                }
                appliedCount++;
            });

            updateStats();
            renderSpreadsheet();
            renderScreeningList();
            if (selectedStudies.size > 0) {
                renderStudyDetails();
            }

            autoSave();

            closeClaudeResponseModal();
            showToast(`${appliedCount} decis√µes aplicadas com sucesso!`, 'success');
        }

        window.onclick = function(event) {
            if (event.target.className === 'modal') {
                event.target.style.display = 'none';
            }
        }

        function checkForSavedProjects() {
            const projects = getAllProjects();
            if (projects.length > 0) {
                console.log(`Found ${projects.length} saved project(s)`);
            }
        }

        function getAllProjects() {
            const projectsData = localStorage.getItem('ward_academy_projects');
            return projectsData ? JSON.parse(projectsData) : [];
        }

        function saveProjectsList(projects) {
            localStorage.setItem('ward_academy_projects', JSON.stringify(projects));
        }

        function generateProjectId() {
            return 'project_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        function createNewProject() {
            const projectName = prompt('Digite o nome do novo projeto:', 'Revis√£o Sistem√°tica - ' + new Date().toLocaleDateString());
            if (!projectName) return;

            const projectId = generateProjectId();
            const projects = getAllProjects();
            
            const newProject = {
                id: projectId,
                name: projectName,
                createdAt: new Date().toISOString(),
                updatedAt: new Date().toISOString(),
                studies: [],
                keywords: {
                    include: [],
                    exclude: [],
                    methods: ['introduction', 'method*', 'result*', 'conclusion*', 'background', 'discussion']
                }
            };

            projects.push(newProject);
            saveProjectsList(projects);
            
            alert(`Projeto "${projectName}" criado com sucesso!`);
            updateProjectsList();
        }

        function triggerImportProject() {
            try {
                const input = document.getElementById('importProjectInput');

                if (!input) {
                    console.error('Input de importa√ß√£o n√£o encontrado!');
                    alert('Erro: Elemento de importa√ß√£o n√£o encontrado. Recarregue a p√°gina.');
                    return;
                }

                // IMPORTANTE: Reset o input antes de abrir o seletor
                // Isso garante que o evento onchange sempre dispare, mesmo selecionando o mesmo arquivo
                input.value = '';

                input.click();
            } catch (error) {
                console.error('Erro em triggerImportProject:', error);
                alert('Erro ao abrir seletor de arquivo: ' + error.message);
            }
        }

        function importProjectFile(event) {
            const file = event.target.files[0];
            if (!file) {
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedProject = JSON.parse(e.target.result);

                    // Validate project structure
                    if (!importedProject.studies || !Array.isArray(importedProject.studies)) {
                        throw new Error('Arquivo inv√°lido: estrutura de projeto n√£o encontrada');
                    }

                    // Ask user for confirmation
                    const projectName = importedProject.projectName || importedProject.name || 'Projeto Importado';
                    const studiesCount = importedProject.studies.length;

                    const confirmImport = confirm(
                        `Deseja importar o projeto "${projectName}"?\n\n` +
                        `üìä Estudos: ${studiesCount}\n` +
                        `üìÖ Criado em: ${importedProject.createdAt ? new Date(importedProject.createdAt).toLocaleString() : 'Data desconhecida'}\n\n` +
                        `O projeto ser√° salvo na sua lista de projetos.`
                    );

                    if (!confirmImport) {
                        event.target.value = ''; // Reset input
                        return;
                    }

                    // Generate new ID to avoid conflicts
                    const projectId = generateProjectId();
                    const projects = getAllProjects();

                    // Check if project with same name exists
                    let finalName = projectName;
                    let counter = 1;
                    while (projects.some(p => p.name === finalName)) {
                        finalName = `${projectName} (${counter})`;
                        counter++;
                    }

                    // Create new project with imported data
                    const newProject = {
                        id: projectId,
                        name: finalName,
                        createdAt: importedProject.createdAt || new Date().toISOString(),
                        updatedAt: new Date().toISOString(),
                        studies: importedProject.studies,
                        keywords: importedProject.keywords || {
                            include: [],
                            exclude: [],
                            methods: ['introduction', 'method*', 'result*', 'conclusion*', 'background', 'discussion']
                        },
                        reviewer: importedProject.reviewer || importedProject.projectName || finalName
                    };

                    // Save project
                    projects.push(newProject);
                    saveProjectsList(projects);

                    // Show success message
                    showToast(`‚úÖ Projeto "${finalName}" importado com sucesso! (${studiesCount} estudos)`, 'success');
                    updateProjectsList();

                    // Ask if user wants to load the imported project
                    const loadNow = confirm('Deseja carregar este projeto agora?');
                    if (loadNow) {
                        loadProject(projectId);
                        closeProjectsModal();
                    }

                } catch (error) {
                    console.error('Erro ao importar projeto:', error);
                    alert(`Erro ao importar projeto: ${error.message}\n\nVerifique se o arquivo √© um export v√°lido do sistema.`);
                }

                // Reset input
                event.target.value = '';
            };

            reader.onerror = function() {
                alert('Erro ao ler o arquivo. Tente novamente.');
                event.target.value = '';
            };

            reader.readAsText(file);
        }

        function loadProject(projectId) {
            const projects = getAllProjects();
            const project = projects.find(p => p.id === projectId);

            if (!project) {
                alert('Projeto n√£o encontrado!');
                return;
            }

            currentProject = project;
            studies = project.studies || [];
            keywords = project.keywords || keywords;

            document.getElementById('currentProjectName').textContent = project.name;
            document.getElementById('uploadArea').classList.add('hidden');
            document.getElementById('mainApp').classList.remove('hidden');

            updateStats();
            renderSpreadsheet();
            renderScreeningList();
            updateRangeInfo();
            updateResultsCounter();

            // Switch to screening mode by default
            switchTab('screening');

            closeProjectsModal();
            
            showToast(`Projeto "${project.name}" carregado com sucesso!`, 'success');
        }

        function saveCurrentProject() {
            if (!currentProject) return;

            const projects = getAllProjects();
            const projectIndex = projects.findIndex(p => p.id === currentProject.id);
            
            if (projectIndex === -1) return;

            projects[projectIndex].studies = studies;
            projects[projectIndex].keywords = keywords;
            projects[projectIndex].updatedAt = new Date().toISOString();

            saveProjectsList(projects);
            currentProject = projects[projectIndex];

            updateAutoSaveStatus('saved');
        }

        function autoSave() {
            if (!autoSaveEnabled || !currentProject) return;
            
            updateAutoSaveStatus('saving');
            
            if (autoSaveTimer) {
                clearTimeout(autoSaveTimer);
            }

            autoSaveTimer = setTimeout(() => {
                saveCurrentProject();
            }, 1000);
        }

        function updateAutoSaveStatus(status) {
            const statusElement = document.getElementById('autoSaveStatus');
            if (!statusElement) return;

            switch(status) {
                case 'saving':
                    statusElement.textContent = 'üíæ Salvando...';
                    statusElement.className = 'text-xs text-yellow-600';
                    break;
                case 'saved':
                    statusElement.textContent = '‚úì Auto-save ativo';
                    statusElement.className = 'text-xs text-green-600';
                    break;
                case 'off':
                    statusElement.textContent = '‚ö†Ô∏è Auto-save desativado';
                    statusElement.className = 'text-xs text-red-600';
                    break;
            }
        }

        function toggleAutoSave() {
            autoSaveEnabled = !autoSaveEnabled;
            const toggleButton = document.getElementById('autoSaveToggle');
            
            if (autoSaveEnabled) {
                toggleButton.textContent = 'ON';
                toggleButton.className = 'text-xs px-2 py-1 bg-green-100 text-green-700 rounded hover:bg-green-200';
                updateAutoSaveStatus('saved');
                showToast('Auto-save ativado', 'success');
            } else {
                toggleButton.textContent = 'OFF';
                toggleButton.className = 'text-xs px-2 py-1 bg-red-100 text-red-700 rounded hover:bg-red-200';
                updateAutoSaveStatus('off');
                showToast('Auto-save desativado', 'warning');
            }
        }

        function toggleDropdown(menuId) {
            const menu = document.getElementById(menuId);
            if (!menu) return;

            // Fechar todos os outros menus
            const allMenus = ['exportMenu', 'toolsMenu'];
            allMenus.forEach(id => {
                if (id !== menuId) {
                    const otherMenu = document.getElementById(id);
                    if (otherMenu) {
                        otherMenu.classList.add('hidden');
                    }
                }
            });

            // Toggle o menu atual
            menu.classList.toggle('hidden');
        }

        // Fechar dropdowns ao clicar fora
        document.addEventListener('click', function(event) {
            const menus = ['exportMenu', 'toolsMenu'];
            const isClickInsideDropdown = event.target.closest('.relative');

            if (!isClickInsideDropdown) {
                menus.forEach(menuId => {
                    const menu = document.getElementById(menuId);
                    if (menu) {
                        menu.classList.add('hidden');
                    }
                });
            }
        });

        function renameProject() {
            if (!currentProject) return;

            const newName = prompt('Digite o novo nome do projeto:', currentProject.name);
            if (!newName || newName === currentProject.name) return;

            const projects = getAllProjects();
            const projectIndex = projects.findIndex(p => p.id === currentProject.id);
            
            if (projectIndex === -1) return;

            projects[projectIndex].name = newName;
            projects[projectIndex].updatedAt = new Date().toISOString();
            saveProjectsList(projects);

            currentProject.name = newName;
            document.getElementById('currentProjectName').textContent = newName;
            
            showToast(`Projeto renomeado para "${newName}"`, 'success');
        }

        function deleteProject(projectId) {
            const projects = getAllProjects();
            const project = projects.find(p => p.id === projectId);
            
            if (!project) return;

            if (!confirm(`Tem certeza que deseja excluir o projeto "${project.name}"?\n\nEsta a√ß√£o n√£o pode ser desfeita!`)) {
                return;
            }

            const filteredProjects = projects.filter(p => p.id !== projectId);
            saveProjectsList(filteredProjects);

            if (currentProject && currentProject.id === projectId) {
                currentProject = null;
                studies = [];
                document.getElementById('mainApp').classList.add('hidden');
                document.getElementById('uploadArea').classList.remove('hidden');
            }

            updateProjectsList();
            showToast('Projeto exclu√≠do com sucesso', 'success');
        }

        function exportProject(projectId) {
            const projects = getAllProjects();
            const project = projects.find(p => p.id === projectId);
            
            if (!project) {
                alert('Projeto n√£o encontrado!');
                return;
            }

            const exportData = {
                projectName: project.name,
                projectId: project.id,
                createdAt: project.createdAt,
                updatedAt: project.updatedAt,
                exportedAt: new Date().toISOString(),
                version: '2.0',
                studies: project.studies,
                keywords: project.keywords,
                stats: {
                    total: project.studies.length,
                    included: project.studies.filter(s => s.included).length,
                    excluded: project.studies.filter(s => s.excluded).length,
                    pending: project.studies.filter(s => !s.included && !s.excluded).length
                }
            };

            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${project.name.replace(/[^a-z0-9]/gi, '_')}_COMPLETO_${Date.now()}.json`;
            link.click();

            showToast('Projeto exportado com sucesso!', 'success');
        }

        function importProjectFile() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = function(event) {
                    try {
                        const importedData = JSON.parse(event.target.result);
                        
                        if (!importedData.projectName || !importedData.studies) {
                            alert('Arquivo de projeto inv√°lido!');
                            return;
                        }

                        const projectId = generateProjectId();
                        const projects = getAllProjects();
                        
                        const newProject = {
                            id: projectId,
                            name: importedData.projectName + ' (Importado)',
                            createdAt: importedData.createdAt || new Date().toISOString(),
                            updatedAt: new Date().toISOString(),
                            studies: importedData.studies,
                            keywords: importedData.keywords || keywords
                        };

                        projects.push(newProject);
                        saveProjectsList(projects);
                        
                        updateProjectsList();
                        showToast(`Projeto "${newProject.name}" importado com sucesso!`, 'success');
                    } catch (error) {
                        alert('Erro ao importar projeto: ' + error.message);
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        function showProjectsModal() {
            updateProjectsList();
            document.getElementById('projectsModal').style.display = 'block';
        }

        function closeProjectsModal() {
            document.getElementById('projectsModal').style.display = 'none';
        }

        function updateProjectsList() {
            const projects = getAllProjects();
            const listDiv = document.getElementById('projectsList');
            
            if (projects.length === 0) {
                listDiv.innerHTML = `
                    <div class="text-center text-gray-500 py-8">
                        <p class="mb-2">Nenhum projeto salvo ainda</p>
                        <p class="text-sm">Crie um novo projeto ou importe dados para come√ßar</p>
                    </div>
                `;
                return;
            }

            projects.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));

            listDiv.innerHTML = '';

            projects.forEach(project => {
                const projectCard = document.createElement('div');
                projectCard.className = `border rounded-lg p-4 hover:bg-gray-50 transition ${currentProject && currentProject.id === project.id ? 'bg-blue-50 border-blue-500' : ''}`;
                
                const updatedDate = new Date(project.updatedAt).toLocaleString('pt-BR');
                const studiesCount = project.studies ? project.studies.length : 0;
                const includedCount = project.studies ? project.studies.filter(s => s.included).length : 0;
                const excludedCount = project.studies ? project.studies.filter(s => s.excluded).length : 0;

                projectCard.innerHTML = `
                    <div class="flex justify-between items-start">
                        <div class="flex-1">
                            <h4 class="font-semibold text-lg mb-1">${project.name}</h4>
                            <p class="text-xs text-gray-500 mb-2">Atualizado: ${updatedDate}</p>
                            <div class="flex gap-3 text-sm">
                                <span class="text-gray-600">üìä ${studiesCount} estudos</span>
                                <span class="text-green-600">‚úì ${includedCount} inclu√≠dos</span>
                                <span class="text-red-600">‚úó ${excludedCount} exclu√≠dos</span>
                            </div>
                        </div>
                        <div class="flex gap-2">
                            ${currentProject && currentProject.id === project.id ? 
                                '<span class="text-xs bg-blue-500 text-white px-2 py-1 rounded">Atual</span>' : 
                                `<button onclick="loadProject('${project.id}')" class="text-xs bg-blue-500 text-white px-3 py-1 rounded hover:bg-blue-600">Abrir</button>`
                            }
                            <button onclick="exportProject('${project.id}')" class="text-xs bg-green-500 text-white px-3 py-1 rounded hover:bg-green-600" title="Exportar projeto">üíæ</button>
                            <button onclick="deleteProject('${project.id}')" class="text-xs bg-red-500 text-white px-3 py-1 rounded hover:bg-red-600" title="Excluir projeto">üóëÔ∏è</button>
                        </div>
                    </div>
                `;
                
                listDiv.appendChild(projectCard);
            });

            const importCard = document.createElement('div');
            importCard.className = 'border-2 border-dashed rounded-lg p-4 text-center hover:bg-gray-50 transition cursor-pointer';
            importCard.onclick = importProjectFile;
            importCard.innerHTML = `
                <p class="text-gray-600 mb-2">üì• Importar Projeto</p>
                <p class="text-xs text-gray-500">Clique para importar um arquivo de projeto (.json)</p>
            `;
            listDiv.appendChild(importCard);
        }

        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = `fixed bottom-6 right-6 px-6 py-3 rounded-lg shadow-lg text-white z-50 transition-opacity`;
            
            switch(type) {
                case 'success':
                    toast.className += ' bg-green-500';
                    break;
                case 'error':
                    toast.className += ' bg-red-500';
                    break;
                case 'warning':
                    toast.className += ' bg-yellow-500';
                    break;
                default:
                    toast.className += ' bg-blue-500';
            }
            
            toast.textContent = message;
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.style.opacity = '0';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }

        function toggleSearchHelp() {
            const isAdvancedMode = document.getElementById('advancedSearchToggle').checked;
            const helpAdvanced = document.getElementById('searchHelpAdvanced');
            const helpSimple = document.getElementById('searchHelpSimple');

            if (isAdvancedMode) {
                helpAdvanced.classList.toggle('hidden');
                helpSimple.classList.add('hidden');
            } else {
                helpSimple.classList.toggle('hidden');
                helpAdvanced.classList.add('hidden');
            }
        }

        function toggleSearchMode() {
            const toggle = document.getElementById('advancedSearchToggle');
            const isAdvanced = toggle.checked;
            const searchInput = document.getElementById('searchInput');
            const modeLabel = document.getElementById('searchModeLabel');

            // Update label
            modeLabel.textContent = isAdvanced ? 'Busca Avan√ßada' : 'Busca Simples';

            // Update placeholder
            if (isAdvanced) {
                searchInput.placeholder = 'üîç Busca avan√ßada: diabetes AND (treatment OR therapy) NOT "case report" author:Smith';
            } else {
                searchInput.placeholder = 'üîç Busca simples: digite palavras-chave (diabetes treatment insulin)';
            }

            // Hide help boxes
            document.getElementById('searchHelpAdvanced').classList.add('hidden');
            document.getElementById('searchHelpSimple').classList.add('hidden');

            // Save preference to localStorage
            localStorage.setItem('advancedSearchMode', isAdvanced);

            // Re-run search if there's a query
            if (searchInput.value.trim()) {
                performSearch();
            }
        }

        function performSearch() {
            const toggle = document.getElementById('advancedSearchToggle');
            const isAdvanced = toggle.checked;

            if (isAdvanced) {
                performAdvancedSearch();
            } else {
                performSimpleSearch();
            }
        }

        function performSimpleSearch() {
            const searchInput = document.getElementById('searchInput');
            const searchInputScreening = document.getElementById('searchInputScreening');

            let query = '';
            if (currentView === 'spreadsheet' && searchInput) {
                query = searchInput.value.trim();
            } else if (currentView === 'screening' && searchInputScreening) {
                query = searchInputScreening.value.trim();
                if (searchInput) searchInput.value = query;
            }

            currentSearchQuery = query;

            if (!query) {
                clearSearch();
                return;
            }

            // Simple search: split query into keywords and find studies containing ANY of them
            const keywords = query.toLowerCase().split(/\s+/).filter(k => k.length > 0);

            searchFilteredStudies = studies.filter(study => {
                // Create searchable text from all fields
                const searchableText = [
                    study.title,
                    study.authors.join(' '),
                    study.year.toString(),
                    study.abstract || '',
                    study.observations || '',
                    study.reasonExclusion || ''
                ].join(' ').toLowerCase();

                // Check if ANY keyword is found in the study
                return keywords.some(keyword => searchableText.includes(keyword));
            });

            applyFilters();
        }

        function clearSearch() {
            document.getElementById('searchInput').value = '';
            if (document.getElementById('searchInputScreening')) {
                document.getElementById('searchInputScreening').value = '';
            }
            currentSearchQuery = '';
            searchFilteredStudies = [];
            applyFilters();
        }

        function performAdvancedSearch() {
            const searchInput = document.getElementById('searchInput');
            const searchInputScreening = document.getElementById('searchInputScreening');
            
            let query = '';
            if (currentView === 'spreadsheet' && searchInput) {
                query = searchInput.value.trim();
            } else if (currentView === 'screening' && searchInputScreening) {
                query = searchInputScreening.value.trim();
                if (searchInput) searchInput.value = query;
            }

            currentSearchQuery = query;

            if (!query) {
                clearSearch();
                return;
            }

            searchFilteredStudies = studies.filter(study => matchStudyWithQuery(study, query));

            applyFilters();
        }

        function matchStudyWithQuery(study, query) {
            try {
                const tokens = tokenizeQuery(query);
                return evaluateQuery(study, tokens);
            } catch (error) {
                console.error('Search error:', error);
                return true;
            }
        }

        function tokenizeQuery(query) {
            const tokens = [];
            let current = '';
            let inQuotes = false;
            let i = 0;

            while (i < query.length) {
                const char = query[i];
                
                if (char === '"') {
                    if (inQuotes) {
                        tokens.push({ type: 'PHRASE', value: current });
                        current = '';
                        inQuotes = false;
                    } else {
                        if (current.trim()) {
                            tokens.push(...parseWord(current.trim()));
                        }
                        current = '';
                        inQuotes = true;
                    }
                } else if (inQuotes) {
                    current += char;
                } else if (char === '(' || char === ')') {
                    if (current.trim()) {
                        tokens.push(...parseWord(current.trim()));
                        current = '';
                    }
                    tokens.push({ type: char === '(' ? 'LPAREN' : 'RPAREN' });
                } else if (char === ' ') {
                    if (current.trim()) {
                        tokens.push(...parseWord(current.trim()));
                        current = '';
                    }
                } else {
                    current += char;
                }
                
                i++;
            }

            if (current.trim()) {
                if (inQuotes) {
                    tokens.push({ type: 'PHRASE', value: current });
                } else {
                    tokens.push(...parseWord(current.trim()));
                }
            }

            return tokens;
        }

        function parseWord(word) {
            const upper = word.toUpperCase();
            
            if (upper === 'AND') return [{ type: 'AND' }];
            if (upper === 'OR') return [{ type: 'OR' }];
            if (upper === 'NOT') return [{ type: 'NOT' }];
            
            const fieldMatch = word.match(/^(\w+):(.+)$/);
            if (fieldMatch) {
                return [{ type: 'FIELD', field: fieldMatch[1].toLowerCase(), value: fieldMatch[2] }];
            }
            
            return [{ type: 'TERM', value: word }];
        }

        function evaluateQuery(study, tokens) {
            if (tokens.length === 0) return true;

            let pos = 0;

            function parseExpression() {
                let left = parseTerm();
                
                while (pos < tokens.length) {
                    const token = tokens[pos];
                    
                    if (token.type === 'OR') {
                        pos++;
                        const right = parseTerm();
                        left = left || right;
                    } else if (token.type === 'AND') {
                        pos++;
                        const right = parseTerm();
                        left = left && right;
                    } else {
                        break;
                    }
                }
                
                return left;
            }

            function parseTerm() {
                const token = tokens[pos];
                
                if (!token) return true;

                if (token.type === 'NOT') {
                    pos++;
                    return !parseTerm();
                }

                if (token.type === 'LPAREN') {
                    pos++;
                    const result = parseExpression();
                    if (tokens[pos] && tokens[pos].type === 'RPAREN') {
                        pos++;
                    }
                    return result;
                }

                if (token.type === 'RPAREN') {
                    return true;
                }

                if (token.type === 'TERM') {
                    pos++;
                    return matchTerm(study, token.value);
                }

                if (token.type === 'PHRASE') {
                    pos++;
                    return matchPhrase(study, token.value);
                }

                if (token.type === 'FIELD') {
                    pos++;
                    return matchField(study, token.field, token.value);
                }

                pos++;
                return true;
            }

            return parseExpression();
        }

        function matchTerm(study, term) {
            const pattern = term.replace(/\*/g, '.*');
            const regex = new RegExp(pattern, 'i');

            const searchableText = [
                study.title,
                study.authors.join(' '),
                study.year.toString(),
                study.abstract || '',
                study.observations || '',
                study.reasonExclusion || ''
            ].join(' ').toLowerCase();

            return regex.test(searchableText);
        }

        function matchPhrase(study, phrase) {
            const searchableText = [
                study.title,
                study.authors.join(' '),
                study.abstract || '',
                study.observations || ''
            ].join(' ').toLowerCase();

            return searchableText.includes(phrase.toLowerCase());
        }

        function matchField(study, field, value) {
            const pattern = value.replace(/\*/g, '.*');
            const regex = new RegExp(pattern, 'i');

            switch(field) {
                case 'title':
                    return regex.test(study.title);
                case 'author':
                case 'authors':
                    return regex.test(study.authors.join(' '));
                case 'year':
                    return study.year.toString() === value || regex.test(study.year.toString());
                case 'abstract':
                    return regex.test(study.abstract || '');
                case 'observations':
                case 'obs':
                    return regex.test(study.observations || '');
                case 'reason':
                case 'exclusion':
                    return regex.test(study.reasonExclusion || '');
                default:
                    return matchTerm(study, value);
            }
        }

        // Deduplication Modal Functions
        function showDoiDeduplicationModal() {
            document.getElementById('doiDuplicateCount').textContent = doiDuplicates.length;

            const listDiv = document.getElementById('doiDuplicatesList');
            listDiv.innerHTML = '';

            doiDuplicates.forEach((group, groupIndex) => {
                const groupDiv = document.createElement('div');
                groupDiv.className = 'duplicate-card';

                let html = `
                    <div class="flex justify-between items-center mb-3">
                        <h3 class="font-bold text-lg">Grupo ${groupIndex + 1} - DOI: ${group.doi}</h3>
                        <div class="flex gap-2">
                            <button onclick="removeDuplicatesFromGroup(${groupIndex}, 'doi')"
                                class="bg-red-500 text-white px-3 py-1 rounded text-sm hover:bg-red-600">
                                üóëÔ∏è Remover Duplicados (manter 1)
                            </button>
                            <button onclick="keepGroupDuplicates(${groupIndex}, 'doi')"
                                class="bg-green-500 text-white px-3 py-1 rounded text-sm hover:bg-green-600">
                                ‚úÖ Manter Todos
                            </button>
                        </div>
                    </div>
                    <div class="space-y-2">
                `;

                group.items.forEach((item, itemIndex) => {
                    html += `
                        <div class="duplicate-item" id="doi-group-${groupIndex}-item-${itemIndex}">
                            <div class="flex justify-between">
                                <div class="flex-1">
                                    <p class="font-semibold text-sm">${item.title}</p>
                                    <p class="text-xs text-gray-600 mt-1">
                                        Autores: ${item.authors.slice(0, 3).join(', ')}${item.authors.length > 3 ? ' et al.' : ''}
                                    </p>
                                    <p class="text-xs text-gray-600">Ano: ${item.year || 'N/A'}</p>
                                </div>
                                <div class="ml-4">
                                    <input type="radio" name="doi-group-${groupIndex}" value="${itemIndex}"
                                        ${itemIndex === 0 ? 'checked' : ''}
                                        onchange="selectDuplicate(${groupIndex}, ${itemIndex}, 'doi')">
                                    <label class="text-xs ml-1">Manter este</label>
                                </div>
                            </div>
                        </div>
                    `;
                });

                html += '</div></div>';
                groupDiv.innerHTML = html;
                listDiv.appendChild(groupDiv);
            });

            document.getElementById('doiDeduplicationModal').style.display = 'block';
        }

        function closeDoiDeduplicationModal() {
            document.getElementById('doiDeduplicationModal').style.display = 'none';
        }

        function selectDuplicate(groupIndex, itemIndex, type) {
            const prefix = type === 'doi' ? 'doi' : 'title';
            const items = document.querySelectorAll(`[id^="${prefix}-group-${groupIndex}-item-"]`);
            items.forEach((item, idx) => {
                if (idx === itemIndex) {
                    item.classList.add('selected');
                } else {
                    item.classList.remove('selected');
                }
            });
        }

        function removeAllDoiDuplicates() {
            doiDuplicates.forEach((group, index) => {
                removeDuplicatesFromGroup(index, 'doi', false);
            });
            duplicatesRemoved.doi = doiDuplicates.reduce((sum, group) => sum + (group.items.length - 1), 0);
            closeDoiDeduplicationModal();
            proceedToTitleDeduplication();
        }

        function removeDuplicatesFromGroup(groupIndex, type, autoClose = true) {
            const group = type === 'doi' ? doiDuplicates[groupIndex] : titleDuplicates[groupIndex];
            const selectedRadio = document.querySelector(`input[name="${type}-group-${groupIndex}"]:checked`);
            const keepIndex = selectedRadio ? parseInt(selectedRadio.value) : 0;

            group.items.forEach((item, index) => {
                if (index !== keepIndex) {
                    item._removeMe = true;
                }
            });

            if (autoClose) {
                if (type === 'doi') {
                    duplicatesRemoved.doi += group.items.length - 1;
                    closeDoiDeduplicationModal();
                    proceedToTitleDeduplication();
                } else {
                    duplicatesRemoved.title += group.items.length - 1;
                    closeTitleDeduplicationModal();
                    finishDeduplication();
                }
            }
        }

        function keepGroupDuplicates(groupIndex, type) {
            if (type === 'doi') {
                doiDuplicates[groupIndex]._kept = true;
            } else {
                titleDuplicates[groupIndex]._kept = true;
            }
        }

        function keepAllDoiDuplicates() {
            closeDoiDeduplicationModal();
            proceedToTitleDeduplication();
        }

        async function proceedToTitleDeduplication() {
            showLoading('Analisando t√≠tulos...', 'Procurando duplicados por t√≠tulo...');
            updateProgress(0);
            await sleep(300);

            // Remove DOI duplicates - use reverse iteration to avoid index issues
            if (doiDuplicates.length > 0) {
                const indicesToRemove = new Set();

                doiDuplicates.forEach(group => {
                    group.items.forEach(item => {
                        if (item._removeMe && item.originalIndex !== undefined) {
                            indicesToRemove.add(item.originalIndex);
                        }
                    });
                });

                // Remove in reverse order to maintain indices
                const sortedIndices = Array.from(indicesToRemove).sort((a, b) => b - a);
                sortedIndices.forEach(index => {
                    if (index >= 0 && index < allFilesStudies.length) {
                        allFilesStudies.splice(index, 1);
                        duplicatesRemoved.doi++;
                    }
                });
            }

            updateProgress(30);
            await sleep(300);

            titleDuplicates = findDuplicatesByTitle(allFilesStudies);

            updateProgress(100);
            await sleep(300);
            hideLoading();

            if (titleDuplicates.length > 0) {
                showTitleDeduplicationModal();
            } else {
                finishDeduplication();
            }
        }

        function showTitleDeduplicationModal() {
            document.getElementById('titleDuplicateCount').textContent = titleDuplicates.length;

            const listDiv = document.getElementById('titleDuplicatesList');
            listDiv.innerHTML = '';

            titleDuplicates.forEach((group, groupIndex) => {
                const groupDiv = document.createElement('div');
                groupDiv.className = 'duplicate-card';

                let html = `
                    <div class="flex justify-between items-center mb-3">
                        <h3 class="font-bold text-lg">Grupo ${groupIndex + 1}</h3>
                        <div class="flex gap-2">
                            <button onclick="removeDuplicatesFromGroup(${groupIndex}, 'title')"
                                class="bg-red-500 text-white px-3 py-1 rounded text-sm hover:bg-red-600">
                                üóëÔ∏è Remover Duplicados (manter 1)
                            </button>
                            <button onclick="keepGroupDuplicates(${groupIndex}, 'title')"
                                class="bg-green-500 text-white px-3 py-1 rounded text-sm hover:bg-green-600">
                                ‚úÖ Manter Todos
                            </button>
                        </div>
                    </div>
                    <div class="space-y-2">
                `;

                group.items.forEach((item, itemIndex) => {
                    html += `
                        <div class="duplicate-item" id="title-group-${groupIndex}-item-${itemIndex}">
                            <div class="flex justify-between">
                                <div class="flex-1">
                                    <p class="font-semibold text-sm">${item.title}</p>
                                    <p class="text-xs text-gray-600 mt-1">
                                        DOI: ${item.doi || 'N/A'} |
                                        Autores: ${item.authors.slice(0, 2).join(', ')}${item.authors.length > 2 ? ' et al.' : ''}
                                    </p>
                                    <p class="text-xs text-gray-600">Ano: ${item.year || 'N/A'}</p>
                                </div>
                                <div class="ml-4">
                                    <input type="radio" name="title-group-${groupIndex}" value="${itemIndex}"
                                        ${itemIndex === 0 ? 'checked' : ''}
                                        onchange="selectDuplicate(${groupIndex}, ${itemIndex}, 'title')">
                                    <label class="text-xs ml-1">Manter este</label>
                                </div>
                            </div>
                        </div>
                    `;
                });

                html += '</div></div>';
                groupDiv.innerHTML = html;
                listDiv.appendChild(groupDiv);
            });

            document.getElementById('titleDeduplicationModal').style.display = 'block';
        }

        function closeTitleDeduplicationModal() {
            document.getElementById('titleDeduplicationModal').style.display = 'none';
        }

        function removeAllTitleDuplicates() {
            titleDuplicates.forEach((group, index) => {
                removeDuplicatesFromGroup(index, 'title', false);
            });
            duplicatesRemoved.title = titleDuplicates.reduce((sum, group) => sum + (group.items.length - 1), 0);
            closeTitleDeduplicationModal();
            finishDeduplication();
        }

        function keepAllTitleDuplicates() {
            closeTitleDeduplicationModal();
            finishDeduplication();
        }

        // Files Confirmation Modal Functions
        function showFilesConfirmationModal(fileStats, totalArticles) {
            const totalFiles = fileStats.length;
            const totalNoYear = fileStats.reduce((sum, f) => sum + f.withoutYear, 0);

            document.getElementById('totalArticlesLoaded').textContent = totalArticles;
            document.getElementById('totalFilesLoaded').textContent = totalFiles;

            const listDiv = document.getElementById('filesListConfirmation');
            listDiv.innerHTML = '';

            fileStats.forEach((stat, index) => {
                const fileDiv = document.createElement('div');
                fileDiv.className = 'bg-gray-50 rounded-lg p-4 border border-gray-200';

                fileDiv.innerHTML = `
                    <div class="flex justify-between items-center">
                        <div class="flex-1">
                            <p class="font-semibold text-sm text-gray-800">${stat.filename}</p>
                            <p class="text-xs text-gray-600 mt-1">
                                <span class="inline-block bg-blue-100 text-blue-800 px-2 py-0.5 rounded">
                                    ${stat.total} artigos
                                </span>
                                ${stat.withYear > 0 ? `
                                <span class="inline-block bg-green-100 text-green-800 px-2 py-0.5 rounded ml-1">
                                    ${stat.withYear} com ano
                                </span>
                                ` : ''}
                                ${stat.withoutYear > 0 ? `
                                <span class="inline-block bg-yellow-100 text-yellow-800 px-2 py-0.5 rounded ml-1">
                                    ${stat.withoutYear} sem ano
                                </span>
                                ` : ''}
                            </p>
                        </div>
                        <button
                            onclick="openCalibrationModal(${index})"
                            class="ml-4 bg-purple-600 hover:bg-purple-700 text-white text-xs px-3 py-2 rounded-lg transition-colors"
                            title="Calibrar parser para este arquivo"
                        >
                            üîß Calibrar
                        </button>
                    </div>
                `;

                listDiv.appendChild(fileDiv);
            });

            // Mostrar aviso se houver artigos sem ano
            if (totalNoYear > 0) {
                document.getElementById('noYearWarning').style.display = 'block';
                document.getElementById('noYearCount').textContent = totalNoYear;
            } else {
                document.getElementById('noYearWarning').style.display = 'none';
            }

            // Update button text for multiple file mode (with deduplication)
            document.getElementById('confirmFilesButton').innerHTML = '‚úÖ Confirmar e Prosseguir para Deduplica√ß√£o';

            document.getElementById('filesConfirmationModal').style.display = 'block';
        }

        function closeFilesConfirmationModal() {
            document.getElementById('filesConfirmationModal').style.display = 'none';
        }

        function showSingleFileConfirmationModal(fileStats, totalArticles) {
            const totalNoYear = fileStats.reduce((sum, f) => sum + f.withoutYear, 0);

            document.getElementById('totalArticlesLoaded').textContent = totalArticles;
            document.getElementById('totalFilesLoaded').textContent = '1';

            const listDiv = document.getElementById('filesListConfirmation');
            listDiv.innerHTML = '';

            fileStats.forEach((stat, index) => {
                const fileDiv = document.createElement('div');
                fileDiv.className = 'bg-gray-50 rounded-lg p-4 border border-gray-200';

                fileDiv.innerHTML = `
                    <div class="flex justify-between items-center">
                        <div class="flex-1">
                            <p class="font-semibold text-sm text-gray-800">${stat.filename}</p>
                            <p class="text-xs text-gray-600 mt-1">
                                <span class="inline-block bg-blue-100 text-blue-800 px-2 py-0.5 rounded">
                                    ${stat.total} artigos
                                </span>
                                ${stat.withYear > 0 ? `
                                <span class="inline-block bg-green-100 text-green-800 px-2 py-0.5 rounded ml-1">
                                    ${stat.withYear} com ano
                                </span>
                                ` : ''}
                                ${stat.withoutYear > 0 ? `
                                <span class="inline-block bg-yellow-100 text-yellow-800 px-2 py-0.5 rounded ml-1">
                                    ${stat.withoutYear} sem ano
                                </span>
                                ` : ''}
                            </p>
                        </div>
                        <button
                            onclick="openCalibrationModal(${index})"
                            class="ml-4 bg-purple-600 hover:bg-purple-700 text-white text-xs px-3 py-2 rounded-lg transition-colors"
                            title="Calibrar parser para este arquivo"
                        >
                            üîß Calibrar
                        </button>
                    </div>
                `;

                listDiv.appendChild(fileDiv);
            });

            // Mostrar aviso se houver artigos sem ano
            if (totalNoYear > 0) {
                document.getElementById('noYearWarning').style.display = 'block';
                document.getElementById('noYearCount').textContent = totalNoYear;
            } else {
                document.getElementById('noYearWarning').style.display = 'none';
            }

            // Update button text for single file mode (no deduplication)
            document.getElementById('confirmFilesButton').innerHTML = '‚úÖ Confirmar e Iniciar Triagem';

            document.getElementById('filesConfirmationModal').style.display = 'block';
        }

        function proceedFromFilesConfirmation() {
            // Check if we're adding additional files to existing project
            if (window.isAddingAdditionalFiles) {
                proceedFromAdditionalFiles();
            } else if (isSingleFileMode) {
                proceedFromSingleFile();
            } else {
                proceedToDeduplication();
            }
        }

        function proceedFromSingleFile() {
            closeFilesConfirmationModal();

            // Assign IDs to studies
            allFilesStudies.forEach((study, index) => {
                if (!study.id) {
                    study.id = index + 1;
                }
            });

            // Create project if needed
            if (!currentProject) {
                const projectName = prompt('Digite o nome do projeto:', 'Revis√£o Sistem√°tica - ' + new Date().toLocaleDateString());
                if (!projectName) {
                    alert('√â necess√°rio dar um nome ao projeto!');
                    return;
                }

                const projectId = generateProjectId();
                currentProject = {
                    id: projectId,
                    name: projectName,
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString(),
                    studies: [],
                    keywords: keywords,
                    deduplication: {
                        doiRemoved: 0,
                        titleRemoved: 0,
                        totalRemoved: 0
                    }
                };
            }

            studies = allFilesStudies;
            currentProject.studies = studies;

            document.getElementById('uploadArea').classList.add('hidden');
            document.getElementById('mainApp').classList.remove('hidden');
            updateStats();
            renderSpreadsheet();
            renderScreeningList();
            updateRangeInfo();
            updateResultsCounter();

            // Switch to screening mode by default
            switchTab('screening');

            const projects = getAllProjects();
            const existingIndex = projects.findIndex(p => p.id === currentProject.id);

            if (existingIndex >= 0) {
                projects[existingIndex] = currentProject;
            } else {
                projects.push(currentProject);
            }

            saveProjectsList(projects);
            document.getElementById('currentProjectName').textContent = currentProject.name;

            showToast(`Projeto iniciado! ${studies.length} estudos carregados (arquivo √∫nico, sem deduplica√ß√£o)`, 'success');
        }

        async function proceedToDeduplication() {
            closeFilesConfirmationModal();

            showLoading('Analisando duplicados...', `${allFilesStudies.length} artigos carregados. Procurando duplicados por DOI...`);
            updateProgress(50);
            await sleep(500);

            doiDuplicates = findDuplicatesByDOI(allFilesStudies);

            updateProgress(100);
            await sleep(300);

            hideLoading();

            if (doiDuplicates.length > 0) {
                showDoiDeduplicationModal();
            } else {
                proceedToTitleDeduplication();
            }
        }

        // Calibration Modal Functions
        let currentCalibrationFileIndex = -1;
        let calibrationMode = null;
        let calibrationExamples = {
            type: [],
            title: [],
            author: [],
            year: [],
            doi: [],
            abstract: []
        };

        function openCalibrationModal(fileIndex) {
            currentCalibrationFileIndex = fileIndex;
            const fileData = fileContents[fileIndex];

            document.getElementById('calibrationFileName').textContent = fileData.filename;

            // Show first 200 lines of the file with syntax highlighting
            const lines = fileData.content.split('\n').slice(0, 200);
            displayHighlightedContent(lines);

            // Reset calibration state
            calibrationMode = null;
            calibrationExamples = {
                type: [],
                title: [],
                author: [],
                year: [],
                doi: [],
                abstract: []
            };
            updateCalibrationUI();

            // Hide test result
            document.getElementById('calibrationTestResult').style.display = 'none';

            document.getElementById('calibrationModal').style.display = 'block';
        }

        function displayHighlightedContent(lines) {
            const contentDiv = document.getElementById('calibrationText');

            // Get custom patterns from calibration examples if available
            const customPatterns = extractPatternsFromExamples(calibrationExamples);

            // Build patterns - use custom if available, otherwise use defaults
            const patterns = {
                type: customPatterns.type ?
                    new RegExp(`^(${customPatterns.type.join('|')})\\s*-`) :
                    /^(TY|PMID)\s*-/,
                title: customPatterns.title ?
                    new RegExp(`^(${customPatterns.title.join('|')})\\s+-`) :
                    /^(TI|T1|ST)\s+-/,
                author: customPatterns.author ?
                    new RegExp(`^(${customPatterns.author.join('|')})\\s+-`) :
                    /^(AU|A1|FAU)\s+-/,
                year: customPatterns.year ?
                    new RegExp(`^(${customPatterns.year.join('|')})\\s+-`) :
                    /^(PY|Y1|DA|DP)\s+-/,
                doi: customPatterns.doi ?
                    new RegExp(`^(${customPatterns.doi.join('|')})\\s+-`) :
                    /^(DO|L2|LID|AID)\s+-/,
                abstract: customPatterns.abstract ?
                    new RegExp(`^(${customPatterns.abstract.join('|')})\\s+-`) :
                    /^(AB|N2)\s+-/,
                end: /^ER\s+-/
            };

            const colors = {
                type: '#ef4444',      // red
                title: '#3b82f6',     // blue
                author: '#8b5cf6',    // purple
                year: '#10b981',      // green
                doi: '#f59e0b',       // amber
                abstract: '#6366f1',  // indigo
                end: '#6b7280'        // gray
            };

            let html = '';
            lines.forEach(line => {
                let matched = false;
                let highlightedLine = line;

                for (const [field, pattern] of Object.entries(patterns)) {
                    if (line.trim().match(pattern)) {
                        const tag = line.trim().match(pattern)[0];
                        const color = colors[field];
                        highlightedLine = line.replace(tag, `<span style="background-color: ${color}20; color: ${color}; font-weight: bold; padding: 1px 3px; border-radius: 2px;">${tag}</span>`);
                        matched = true;
                        break;
                    }
                }

                html += highlightedLine + '\n';
            });

            contentDiv.innerHTML = html;
        }

        function closeCalibrationModal() {
            document.getElementById('calibrationModal').style.display = 'none';
            const contentDiv = document.getElementById('calibrationText');
            contentDiv.removeEventListener('mouseup', handleTextSelection);
        }

        function setCalibrationMode(mode) {
            calibrationMode = mode;
            updateCalibrationUI();

            // Add mouseup listener when mode is set
            const contentDiv = document.getElementById('calibrationText');
            contentDiv.removeEventListener('mouseup', handleTextSelection);
            contentDiv.addEventListener('mouseup', handleTextSelection);
        }

        function handleTextSelection() {
            if (!calibrationMode) {
                alert('Por favor, selecione um campo (T√≠tulo, Autor, Ano, etc.) antes de selecionar o texto.');
                return;
            }

            const selection = window.getSelection();
            const selectedText = selection.toString().trim();

            if (selectedText.length > 0) {
                // Add to examples
                calibrationExamples[calibrationMode].push(selectedText);
                updateCalibrationUI();

                // Clear selection
                selection.removeAllRanges();
            }
        }

        function updateCalibrationUI() {
            // Update current mode indicator
            document.getElementById('currentCalibMode').textContent =
                calibrationMode ? calibrationMode.charAt(0).toUpperCase() + calibrationMode.slice(1) : 'Nenhum';

            // Highlight active button
            ['type', 'title', 'author', 'year', 'doi', 'abstract'].forEach(field => {
                const btn = document.getElementById('calibBtn_' + field);
                if (field === calibrationMode) {
                    btn.className = btn.className.replace('bg-gray-100', 'bg-purple-200 font-semibold');
                } else {
                    btn.className = btn.className.replace('bg-purple-200 font-semibold', 'bg-gray-100');
                }
            });

            // Update examples list
            const examplesDiv = document.getElementById('calibrationExamples');
            let html = '';

            for (const [field, examples] of Object.entries(calibrationExamples)) {
                if (examples.length > 0) {
                    const emoji = {
                        type: 'üî¥',
                        title: 'üìÑ',
                        author: 'üë§',
                        year: 'üìÖ',
                        doi: 'üîó',
                        abstract: 'üìù'
                    }[field];

                    html += `<div class="mb-2"><strong>${emoji} ${field}:</strong></div>`;
                    examples.forEach((ex, i) => {
                        const truncated = ex.length > 60 ? ex.substring(0, 60) + '...' : ex;
                        html += `<div class="bg-white p-1 rounded text-gray-700 mb-1">
                            ${i + 1}. ${truncated}
                            <button onclick="removeCalibrationExample('${field}', ${i})" class="text-red-500 ml-2">‚úñ</button>
                        </div>`;
                    });
                }
            }

            if (html === '') {
                html = '<p class="text-gray-400 italic">Nenhum exemplo ainda...</p>';
            }

            examplesDiv.innerHTML = html;

            // Re-render highlighted content with updated patterns
            const fileData = fileContents[currentCalibrationFileIndex];
            const lines = fileData.content.split('\n').slice(0, 200);
            displayHighlightedContent(lines);
        }

        function removeCalibrationExample(field, index) {
            calibrationExamples[field].splice(index, 1);
            updateCalibrationUI();
        }

        function clearCalibration() {
            calibrationExamples = {
                title: [],
                author: [],
                year: [],
                doi: [],
                abstract: []
            };
            calibrationMode = null;
            updateCalibrationUI();
        }

        function applyCalibration() {
            // Extract patterns from examples
            const patterns = extractPatternsFromExamples(calibrationExamples);

            if (Object.keys(patterns).length === 0) {
                alert('Por favor, adicione pelo menos um exemplo antes de aplicar a calibra√ß√£o.');
                return;
            }

            // Save patterns for this file type
            const fileData = fileContents[currentCalibrationFileIndex];
            saveParserRules(fileData.filename, patterns);

            alert('Calibra√ß√£o aplicada com sucesso! O parser agora usar√° os padr√µes definidos para este tipo de arquivo.');
            closeCalibrationModal();
        }

        function extractPatternsFromExamples(examples) {
            const patterns = {};

            for (const [field, exampleList] of Object.entries(examples)) {
                if (exampleList.length > 0) {
                    // Extract tag patterns from examples
                    const tags = new Set();

                    exampleList.forEach(example => {
                        // Look for RIS-style tags (e.g., "TI  -", "AU  -")
                        const tagMatch = example.match(/^([A-Z0-9]{2,4})\s*-/);
                        if (tagMatch) {
                            tags.add(tagMatch[1]);
                        }
                    });

                    if (tags.size > 0) {
                        patterns[field] = Array.from(tags);
                    }
                }
            }

            return patterns;
        }

        let customParserRules = {};

        function saveParserRules(filename, patterns) {
            // Determine file type from extension
            const fileType = filename.toLowerCase().endsWith('.nbib') ? 'nbib' : 'ris';

            customParserRules[fileType] = patterns;

            console.log('Custom parser rules saved:', customParserRules);
        }

        function testCalibration() {
            const patterns = extractPatternsFromExamples(calibrationExamples);

            if (Object.keys(patterns).length === 0) {
                alert('Por favor, adicione pelo menos um exemplo antes de testar.');
                return;
            }

            // Get a random article from the file content
            const fileData = fileContents[currentCalibrationFileIndex];
            const lines = fileData.content.split('\n');

            // Find random TY record
            const tyIndices = [];
            for (let i = 0; i < lines.length; i++) {
                if (lines[i].trim().match(/^TY\s+-/)) {
                    tyIndices.push(i);
                }
            }

            if (tyIndices.length < 2) {
                alert('N√£o h√° artigos suficientes no arquivo para testar.');
                return;
            }

            // Pick random article (not the first one which might be in view)
            const randomIndex = Math.floor(Math.random() * (tyIndices.length - 1)) + 1;
            const startLine = tyIndices[randomIndex];
            const endLine = randomIndex + 1 < tyIndices.length ? tyIndices[randomIndex + 1] : lines.length;

            // Extract article lines
            const articleLines = lines.slice(startLine, endLine);

            // Test patterns on this article
            const testResults = {};
            for (const [field, tags] of Object.entries(patterns)) {
                const pattern = new RegExp(`^(${tags.join('|')})\\s+-`, 'i');
                const foundLines = articleLines.filter(line => line.trim().match(pattern));
                testResults[field] = {
                    tags: tags,
                    found: foundLines.length > 0,
                    lines: foundLines
                };
            }

            // Display results
            displayTestResults(testResults, articleLines);
        }

        function displayTestResults(results, articleLines) {
            const resultDiv = document.getElementById('calibrationTestResult');
            const contentDiv = document.getElementById('calibrationTestContent');

            let html = '<div class="space-y-2">';
            html += '<p class="font-semibold">Testando em artigo aleat√≥rio do arquivo...</p>';
            html += '<div class="bg-white rounded p-2 border border-green-200 mb-2">';
            html += '<p class="font-mono text-xs text-gray-600">' + articleLines.slice(0, 10).join('<br>') + '</p>';
            if (articleLines.length > 10) html += '<p class="text-gray-400 italic">... (primeiras 10 linhas)</p>';
            html += '</div>';

            for (const [field, result] of Object.entries(results)) {
                const emoji = {
                    title: 'üìÑ',
                    author: 'üë§',
                    year: 'üìÖ',
                    doi: 'üîó',
                    abstract: 'üìù'
                }[field];

                if (result.found) {
                    html += `<div class="flex items-center gap-2">
                        <span class="text-green-600 font-bold">‚úÖ</span>
                        <span>${emoji} <strong>${field}:</strong> Encontrado com tags [${result.tags.join(', ')}]</span>
                    </div>`;
                    if (result.lines.length > 0) {
                        html += `<div class="ml-6 font-mono text-xs bg-green-100 p-1 rounded">${result.lines[0].substring(0, 80)}...</div>`;
                    }
                } else {
                    html += `<div class="flex items-center gap-2">
                        <span class="text-red-600 font-bold">‚ùå</span>
                        <span>${emoji} <strong>${field}:</strong> N√ÉO encontrado com tags [${result.tags.join(', ')}]</span>
                    </div>`;
                }
            }

            html += '</div>';
            contentDiv.innerHTML = html;
            resultDiv.style.display = 'block';
        }

        function finishDeduplication() {
            // Remove title duplicates - use reverse iteration to avoid index issues
            if (titleDuplicates.length > 0) {
                const indicesToRemove = new Set();

                titleDuplicates.forEach(group => {
                    group.items.forEach(item => {
                        if (item._removeMe && item.originalIndex !== undefined) {
                            indicesToRemove.add(item.originalIndex);
                        }
                    });
                });

                // Remove in reverse order to maintain indices
                const sortedIndices = Array.from(indicesToRemove).sort((a, b) => b - a);
                sortedIndices.forEach(index => {
                    if (index >= 0 && index < allFilesStudies.length) {
                        allFilesStudies.splice(index, 1);
                        duplicatesRemoved.title++;
                    }
                });
            }

            // Check if we're adding to existing project
            const isAddingToExisting = window.isAddingAdditionalFiles && currentProject && studies.length > 0;

            if (isAddingToExisting) {
                // When adding to existing project, preserve decisions
                // First, identify which studies were already in the project (have IDs)
                const existingStudiesById = new Map();
                studies.forEach(study => {
                    if (study.id) {
                        existingStudiesById.set(study.id, study);
                    }
                });

                // Now go through allFilesStudies and preserve decisions for existing ones
                allFilesStudies.forEach(study => {
                    if (study.id && existingStudiesById.has(study.id)) {
                        const existingStudy = existingStudiesById.get(study.id);
                        // Preserve all decision data
                        study.included = existingStudy.included;
                        study.excluded = existingStudy.excluded;
                        study.decision = existingStudy.decision;
                        study.reasonExclusion = existingStudy.reasonExclusion;
                        study.observations = existingStudy.observations;
                        study.pdfFound = existingStudy.pdfFound;
                    }
                });

                // Assign IDs only to truly new studies (those without IDs)
                const maxId = Math.max(...allFilesStudies.filter(s => s.id).map(s => s.id), 0);
                let nextId = maxId + 1;
                allFilesStudies.forEach(study => {
                    if (!study.id) {
                        study.id = nextId++;
                    }
                });

                // Update current project
                studies = allFilesStudies;
                currentProject.studies = studies;
                currentProject.updatedAt = new Date().toISOString();

                // Update deduplication stats in project
                if (!currentProject.deduplication) {
                    currentProject.deduplication = {
                        doiRemoved: 0,
                        titleRemoved: 0,
                        totalRemoved: 0
                    };
                }
                currentProject.deduplication.doiRemoved += duplicatesRemoved.doi;
                currentProject.deduplication.titleRemoved += duplicatesRemoved.title;
                currentProject.deduplication.totalRemoved += (duplicatesRemoved.doi + duplicatesRemoved.title);

                // Save and update UI
                const projects = getAllProjects();
                const existingIndex = projects.findIndex(p => p.id === currentProject.id);
                if (existingIndex >= 0) {
                    projects[existingIndex] = currentProject;
                }
                saveProjectsList(projects);

                updateStats();
                renderSpreadsheet();
                renderScreeningList();
                updateRangeInfo();
                updateResultsCounter();

                // Switch to screening mode by default
                switchTab('screening');

                const totalRemoved = duplicatesRemoved.doi + duplicatesRemoved.title;
                showToast(`Arquivos adicionados! ${studies.length} estudos totais (${totalRemoved} duplicados removidos: ${duplicatesRemoved.doi} por DOI, ${duplicatesRemoved.title} por t√≠tulo). Suas decis√µes anteriores foram preservadas!`, 'success');

                // Reset the flag
                window.isAddingAdditionalFiles = false;
                duplicatesRemoved.doi = 0;
                duplicatesRemoved.title = 0;

            } else {
                // Original flow for new projects
                // Assign IDs to studies
                allFilesStudies.forEach((study, index) => {
                    if (!study.id) {
                        study.id = index + 1;
                    }
                });

                // Now use parseRISFile logic to continue with the app
                if (!currentProject) {
                    const projectName = prompt('Digite o nome do projeto:', 'Revis√£o Sistem√°tica - ' + new Date().toLocaleDateString());
                    if (!projectName) {
                        alert('√â necess√°rio dar um nome ao projeto!');
                        return;
                    }

                    const projectId = generateProjectId();
                    currentProject = {
                        id: projectId,
                        name: projectName,
                        createdAt: new Date().toISOString(),
                        updatedAt: new Date().toISOString(),
                        studies: [],
                        keywords: keywords,
                        deduplication: {
                            doiRemoved: duplicatesRemoved.doi,
                            titleRemoved: duplicatesRemoved.title,
                            totalRemoved: duplicatesRemoved.doi + duplicatesRemoved.title
                        }
                    };
                }

                studies = allFilesStudies;
                currentProject.studies = studies;

                document.getElementById('uploadArea').classList.add('hidden');
                document.getElementById('mainApp').classList.remove('hidden');
                updateStats();
                renderSpreadsheet();
                renderScreeningList();
                updateRangeInfo();
                updateResultsCounter();

                // Switch to screening mode by default
                switchTab('screening');

                const projects = getAllProjects();
                const existingIndex = projects.findIndex(p => p.id === currentProject.id);

                if (existingIndex >= 0) {
                    projects[existingIndex] = currentProject;
                } else {
                    projects.push(currentProject);
                }

                saveProjectsList(projects);
                document.getElementById('currentProjectName').textContent = currentProject.name;

                const totalRemoved = duplicatesRemoved.doi + duplicatesRemoved.title;
                showToast(`Projeto iniciado! ${studies.length} estudos √∫nicos (${totalRemoved} duplicados removidos: ${duplicatesRemoved.doi} por DOI, ${duplicatesRemoved.title} por t√≠tulo)`, 'success');
            }
        }
    </script>
</body>
</html>
